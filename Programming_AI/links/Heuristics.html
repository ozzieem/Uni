<!DOCTYPE html>
<!-- saved from url=(0068)http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html#S7 -->
<html lang="en" class="gr__theory_stanford_edu"><style type="text/css" id="night-mode-pro-style"></style><link type="text/css" rel="stylesheet" id="night-mode-pro-link"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Heuristics</title><meta name="viewport" content="width=640"><link rel="shortcut icon" href="http://theory.stanford.edu/~amitp/favicon.ico"><link rel="apple-touch-icon" href="http://theory.stanford.edu/~amitp/red_blob.gif"><link href="https://fonts.googleapis.com/css?family=Roboto+Slab:700%7COpen+Sans%27%20rel=%27stylesheet"><link href="http://disqus.com/embed/comments/" rel="preconnect"><link href="http://a.disquscdn.com/" rel="preconnect"><link rel="canonical" href="http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html"><link rel="alternate" type="application/atom+xml" title="Blobs in Games - Atom" href="http://simblob.blogspot.com/feeds/posts/default"><meta name="twitter:creator" content="@redblobgames"><meta name="verify-v1" content="82b+h1+tgwLrcTqTiJrqquMvoFVBwMwY11dx63m01zk="><meta name="robots" content="noodp"><script async="" type="text/javascript" src="http://www.google-analytics.com/ga.js"></script><script async="" type="text/javascript" src="./Heuristics_files/gap.min.js.download"></script><script><!--
            (function() {
            var link = document.createElement('link');
            link.href = 'http://fonts.googleapis.com/css?family=Source+Code+Pro:400,700|Source+Sans+Pro:400,400italic,700italic,700';
            link.rel = 'stylesheet';
            link.type = 'text/css';
            if (document.location.hostname != 'localhost') document.getElementsByTagName('html')[0].appendChild(link);
            })();
          //--></script><style>
              body{font-family:"Source Sans Pro", "Open Sans", "Lucida Grande", "Lucida Sans Unicode", "Lucida Sans", "Tahoma", sans-serif;font-size:14px;line-height:1.5;min-height:95%}body.width600{font-size:16px}tt,code,kbd,samp,pre{font-family:"Source Code Pro", monospace, serif, "Segoe UI Symbol", "Symbol";font-size:12px;font-size-adjust:none}.width600 tt,.width600 code,.width600 kbd,.width600 samp,.width600 pre{font-size:14px}nav{font-size:14px}header,h2{text-shadow:0px 2px 5px rgba(0,0,0,0.8);text-rendering:optimizeLegibility;-webkit-font-feature-settings:"kern";-moz-font-feature-settings:"kern";-moz-font-feature-settings:"liga=1,pnum=1,onum=1,kern=1";-ms-font-feature-settings:"liga" 1, "pnum" 1, "onum" 1, "kern" 1;font-kerning:normal}h1{font-size:28px}h1 .subheading{letter-spacing:normal;font-size:14px}.width600 h1{font-size:32px}.width600 h1 .subheading{font-size:16px}sup,sub{position:relative;vertical-align:baseline;font-size:75%;line-height:0;padding-left:2px}sup{top:-0.5em}sub{bottom:-0.25em}*{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}html,body{margin:0;padding:0}body{background-color:#fff;color:#333}.main{max-width:1075px;margin-left:auto;margin-right:auto;padding:0 40px}header{display:block;text-align:center}h1{margin:0;padding:28px;padding-left:80px;text-align:left}.colored-background{color:#fff;background-color:#bf4040}header,.footer,.divider,h2{color:#fff;background-color:#bf4040;-webkit-font-smoothing:antialiased}header a,.footer a,.divider a,h2 a{color:#f2d9d9}.footer a,.divider a{text-decoration:underline}.comments,.divider-disqus{background-color:#e4e4e0}.comments{padding-bottom:20px;text-shadow:1px 1px 3px #fff}h2{margin:20px 0;padding:10px 40px;font-size:20px;max-width:530px}.width600 h2{max-width:680px}h2 a.anchor{float:right;width:2em;text-align:right;color:#bf4040}h2:hover a.anchor{color:#df9f9f}h3{margin:18px 0;font-size:18px}nav{display:block}nav ul{text-align:center;line-height:1.0;margin:0}nav ul li{display:inline-block;padding:2px 5px;text-align:center;width:10%;white-space:nowrap}nav ul li a{display:block;width:100%;font-weight:bold;text-decoration:none}nav ul li.nav:hover{background-color:rgba(0,0,0,0.5);font-weight:bold}nav ul li.navself{background-color:rgba(0,0,0,0.3);font-weight:bold}.topic{margin-left:40px;margin-right:40px;margin-bottom:35px;max-width:450px}.width600 .topic{max-width:600px}header,.divider,h2{border-bottom:1px solid #000}.divider,.footer,h2{border-top:1px solid #000}.divider{min-height:28px;padding-left:2.5em}.divider-disqus{padding-top:14px;text-align:center}.footer{clear:both;padding:7px 14px;border-top:1px solid #000}.footer p{max-width:40em;line-height:1.1}h2:target{-webkit-animation:target-attention 0.4s 1;-moz-animation:target-attention 0.4s 1}@-webkit-keyframes target-attention{0%{-webkit-transform:scale(1.1);transform:scale(1.1)}100%{-webkit-transform:scale(1);transform:scale(1.1)}}@-moz-keyframes target-attention{0%{-moz-transform:scale(1.1);transform:scale(1.1)}100%{-moz-transform:scale(1);transform:scale(1)}}h2:target{font-size:24px}div:target{border:1px dashed #888}kbd kbd{padding:1px 7px;margin:0px 1px 3px 1px;display:inline-block;font-size:11px;font-family:"Helvetica Neue", "Helvetica", "Tahoma", "Arial", sans-serif;white-space:nowrap;background:#ddd;color:#242;border:1px solid rgba(0,0,0,0.2);border-radius:3px;box-shadow:inset 0 0 1px 1px #fff,0 2px 0 rgba(0,0,0,0.3)}samp,kbd{background-color:#f4f4f0}code,samp{color:#442}kbd{margin:0 7px;color:#252}.topic>img{max-width:100%;-ms-interpolation-mode:bicubic}.topic figcaption{font-size:12px;text-align:center}a{color:#bf4040;text-decoration:none}a:hover{text-decoration:underline}.topic p,.topic li{text-align:justify;-moz-hyphens:auto;-ms-hyphens:auto;-webkit-hyphens:auto;hyphens:auto}nav,figure,abbr,acronym,code,kbd,samp,tt,var,pre{-moz-hyphens:none;-ms-hyphens:none;-webkit-hyphens:none;hyphens:none}p,ul,ol,ul.spaced>li,ol.spaced>li{margin:1.25em 0}ul ul,ul ol,ol ul,ol ol,li ul,li ol{margin:0}ul,ol{margin-left:0;padding-left:21px}dt{font-weight:bold}pre{max-width:450px;line-height:1.4;font-size:12px;padding:4px 12px;overflow:auto;white-space:pre-wrap;border-top:1px solid #ccc;border-bottom:1px solid #ccc;border-left-width:0;border-right-width:0}.width600 pre{max-width:600px}.width600 pre{font-size:14px}pre::-webkit-scrollbar{height:1em}pre::-webkit-scrollbar-thumb:horizontal{border-radius:0.5em;background:rgba(0,0,0,0.4)}ul pre,ol pre{width:450px}pre.simple,.comments pre{overflow:visible;width:100%;border:none;background:transparent;background-color:transparent;box-shadow:none}pre.snippet,pre.src{border-top-style:dashed;border-bottom-style:dashed}.topic>pre:only-child{padding-bottom:14px;border-bottom:1px solid rgba(0,0,0,0.5)}blockquote{font-style:italic}table.standard{border:1px solid rgba(0,0,0,0.5);border-collapse:collapse}table.standard th{background-color:#f8f8f8;background:linear-gradient(to bottom, #f8f8f8,#f8f8f8,#f0f0f0)}table.standard td{background-color:#fff}table.standard th,table.standard td{border:1px solid rgba(0,0,0,0.5)}p.note,div.note>p{margin:1em;padding:1em;background:#eee;border:1px solid #ddd;box-shadow:0 8px 6px -6px rgba(0,0,0,0.4)}svg{overflow:hidden}tt,code{padding:0 2px}address{max-width:450px;text-align:right}.footer address{text-align:left}@media only screen and (max-width: 700px){.main{padding:0 10px}.topic{margin-left:10px;margin-right:10px}h2{max-width:400px}pre{font-size:10px}.width600 pre{font-size:11px}nav{font-size:12px}}@media only screen and (max-width: 600px){header,.footer{font-size:12px}h1{text-align:center;font-size:14px;padding:14px}nav span.longnav,nav form{display:none}nav ul li{width:15%}.omit-if-narrow,nav ul li.omit-if-narrow{display:none}pre{width:auto;font-size:9px}nav{font-size:10px}}form{margin:0}input[type="text"]{max-width:100%;border:1px solid rgba(0,0,0,0.7);background-color:#f8f8f4;color:#000;text-align:center;font-weight:bold}input[type="text"]:focus{background-color:#fffff4}input::-webkit-input-placeholder{color:#aaa}input::-moz-placeholder{color:#aaa}.TODO{color:#bf4040;background:#e8e3e3;border:1px solid #bf4040;margin-left:0.5ex}.DONE{color:#4040bf;background:#e3e3e8;border:1px solid #4040bf}pre.src .comment-delimiter,pre.src .nxml-comment-delimiter{color:#4488ff}pre.src .comment,pre.src .nxml-comment-content{color:#006699}pre.src .keyword{color:#406abf;font-weight:bold}pre.src .builtin{color:#508b20}pre.src .warning{color:#cc0000}pre.src .function-name{color:#268bd2;font-weight:bold}pre.src .variable-name{color:#00008b}pre.src .type{color:#6c71c4}pre.src .constant-face{color:#d33682}pre.src .doc{color:#666666;background-color:#e2e6e8}pre.src .string{color:#888888}pre.src .preprocessor{color:#859900}pre.src .negation-char,pre.src .sh-escaped-newline{color:#ff0000}pre.src .todo{color:#ffffff;background:#dc322f}pre.src .note{color:#ffffff;background:#2aa198}pre.src .hack{color:#ffffff;background:#859900}pre.src .paren{color:#a0a090;font-weight:bold}pre.src .minor-control-construct{color:#268bd2}pre.src .major-control-construct{color:#bf4040}pre.src-emacs-lisp .paren{color:#c9c9c4}pre.src-sh .string,pre.src-sh .comment{color:inherit}pre.src-python .highlight-indentation{border-right:2px solid #eeeeee}pre.src-xml .nxml-element-local-name{color:#406abf;font-weight:normal}pre.src-xml .nxml-tag-delimiter,pre.src-xml .nxml-tag-slash{color:#9cabc9;font-weight:bold}table.standard td.left,table.standard th.left{text-align:left}table.standard td.center,table.standard th.center{text-align:center}table.standard td.right,table.standard th.right{text-align:right}*[class^="section-number"]{color:#966}h2 *[class^="section-number"]{color:#e6b3b3;text-align:right;display:inline-block;margin-left:-40px;width:40px}h3 *[class^="section-number"]{color:#e6b3b3;background-color:#bf4040;border-top:1px solid black;border-bottom:1px solid black;text-shadow:0px 2px 5px rgba(0,0,0,0.8);text-rendering:optimizeLegibility;text-align:center;display:inline-block;padding:4px 0;width:40px;margin-left:-40px}@media only screen and (max-width: 700px){h3 *[class^="section-number"]{margin-left:-10px}}#table-of-contents{background-color:#fff;margin-left:40px;padding-left:40px;width:300px;float:right}#table-of-contents:after{clear:both}#table-of-contents h2{text-shadow:none;color:#000;background-color:transparent;background-image:none;padding:0;border-bottom:none;border-top:none}@media print{body{font-family:"Book Antiqua", "Times New Roman", serif;font-size:12pt;line-height:1.25}h1,h2,h3,h4,h5,h6,.footer,.divider-disqus{font-family:"Helvetica", sans-serif;font-size:12pt;text-rendering:optimizeLegibility}h1{font-size:18pt}h1 .subheading{font-size:12pt}header,h2{text-shadow:none}tt,code,kbd,samp,pre{font-family:"Courier", "Courier New", monospace;font-size:12pt}nav,.comments{display:none}}header,.footer,.divider,h2{background-image:url("/~amitp/transparent-blob.png"),url("/~amitp/transparent-blob.png");background-position:0 0, 16px 16px}

            
  ol li { list-style-type: decimal; }
  ol ol li { list-style-type: lower-alpha; }
  ol ol ol li { list-style-type: lower-roman; }
  div.figure { margin-left: 0em; text-align: center; }
  .astar-nav { line-height: 1.5; margin-bottom: 14px; font-size: 18px; text-align: center; background: #eee; border-top: 1px solid #ddd; border-bottom: 1px solid #ddd; }
  .astar-nav span { display: inline-block; width: 30%; }
  /* A note that should go on the right side of the page, in the margin. */
  .astar-note {
      float: right;
      margin-right: -280px;
      margin-left: 0;
      padding: 14px;
      width: 210px;
      border: 1px solid rgba(0, 0, 0, 0.3);
      background-color: rgba(0, 0, 0, 0.1);
      border-radius: 10px;
  }
</style><script type="text/javascript" async="" src="./Heuristics_files/embed.js.download"></script><script type="text/javascript" src="chrome-extension://bfbmjmiodbnnpllbbbfblcplfjjepjdn/js/injected.js"></script></head><link href="./Heuristics_files/css" rel="stylesheet" type="text/css"><body class="gameprog width600" data-gr-c-s-loaded="true"><header><h1 role="banner"><div class="title">Heuristics</div><div class="subheading">
    &nbsp; From <a href="http://theory.stanford.edu/~amitp/GameProgramming/">Amit’s Thoughts on Pathfinding</a></div></h1><nav role="navigation"><form action="https://www.google.com/search"><ul> <li class="nav"><a href="http://www.redblobgames.com/">Home</a></li> <li class="nav"><a href="http://simblob.blogspot.com/">Blog</a></li> <li class="nav omit-if-narrow"><a href="http://pinboard.in/u:amitp/t:gamedev/">Links</a></li> <li class="nav omit-if-narrow"><a href="https://twitter.com/redblobgames">Twitter</a></li> <li class="nav"><a rel="me" href="http://www-cs-students.stanford.edu/~amitp/">About</a></li> <li class="nav omit-if-narrow"> </li><li class="nav omit-if-narrow"><input type="search" name="q" placeholder="Search" size="8"></li></ul><input type="hidden" name="hq" value="site:www.redblobgames.com OR site:theory.stanford.edu/~amitp/ OR site:www-cs-students.stanford.edu/~amitp/ OR site:amitp.blogspot.com OR site:simblob.blogspot.com"></form></nav></header><div class="main" role="main"><div class="topic"><p>The heuristic function <code>h(n)</code> tells A* an <em>estimate</em> of the minimum cost from any vertex <code>n</code> to the goal. It’s important to choose a good heuristic function.</p></div><div class="h2banner"><h2 id="a-stars-use-of-the-heuristic"><a class="anchor" href="http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html#a-stars-use-of-the-heuristic">#</a>A*’s Use of the Heuristic</h2></div><div class="topic"><p>The heuristic can be used to control A*’s behavior.</p><ul><li>At one extreme, if <code>h(n)</code> is 0, then only <code>g(n)</code> plays a role, and A* turns into Dijkstra’s algorithm, which is guaranteed to find a shortest path.</li><li>If <code>h(n)</code> is always lower than (or equal to) the cost of moving from <code>n</code> to the goal, then A* is guaranteed to find a shortest path. The lower <code>h(n)</code> is, the more node A* expands, making it slower.</li><li>If <code>h(n)</code> is exactly equal to the cost of moving from <code>n</code> to the goal, then A* will only follow the best path and never expand anything else, making it very fast. Although you can’t make this happen in all cases, you can make it exact in some special cases. It’s nice to know that given perfect information, A* will behave perfectly.</li><li>If <code>h(n)</code> is sometimes greater than the cost of moving from <code>n</code> to the goal, then A* is not guaranteed to find a shortest path, but it can run faster.</li><li>At the other extreme, if <code>h(n)</code> is very high relative to <code>g(n)</code>, then only <code>h(n)</code> plays a role, and A* turns into Greedy Best-First-Search.</li></ul><div class="astar-note" align="center"><strong>Note:</strong><br> Technically, the <strong>A*</strong> algorithm should be called simply <strong>A</strong> if the heuristic is an underestimate of the actual cost. However, I will continue to call it <strong>A*</strong> because the implementation is the same and the game programming community does not distinguish <strong>A</strong> from <strong>A*</strong>.<br></div><p>So we have an interesting situation in that we can decide what we want to get out of A*. At exactly the right point, we’ll get shortest paths really quickly. If we’re too low, then we’ll continue to get shortest paths, but it’ll slow down. If we’re too high, then we give up shortest paths, but A* will run faster.</p><p>In a game, this property of A* can be very useful. For example, you may find that in some situations, you would rather have a “good” path than a “perfect” path. To shift the balance between <code>g(n)</code> and <code>h(n)</code>, you can modify either one.</p></div><div class="h2banner"><h2 id="speed-or-accuracy"><a class="anchor" href="http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html#speed-or-accuracy">#</a>Speed or accuracy?</h2></div><div class="topic"><p>A*’s ability to vary its behavior based on the heuristic and cost functions can be very useful in a game. The tradeoff between speed and accuracy can be exploited to make your game faster. For most games, you don’t <em>really</em> need the <strong>best</strong> path between two points. You <a href="http://realtimecollisiondetection.net/blog/?p=56">need something that’s close</a>. What you need may depend on what’s going on in the game, or how fast the computer is.</p><p>Suppose your game has two types of terrain, Flat and Mountain, and the movement costs are 1 for flat land and 3 for mountains, A* is going to search three times as far along flat land as it does along mountainous land. This is because it’s <em>possible</em> that there is a path along flat terrain that goes around the mountains. You can speed up A*’s search by using 1.5 as the heuristic distance between two map spaces. A* will then compare 3 to 1.5, and it won’t look as bad as comparing 3 to 1. It is not as dissatisfied with mountainous terrain, so it won’t spend as much time trying to find a way around it. Alternatively, you can speed up up A*’s search by decreasing the amount it searches for paths around mountains―tell A* that the movement cost on mountains is 2 instead of 3. Now it will search only twice as far along the flat terrain as along mountainous terrain. Either approach gives up ideal paths to get something quicker.</p><p>The choice between speed and accuracy does not have to be static. You can choose dynamically based on the CPU speed, the fraction of time going into pathfinding, the number of units on the map, the importance of the unit, the size of the group, the difficulty level, or any other factor. One way to make the tradeoff dynamic is to build a heuristic function that assumes the minimum cost to travel one grid space is 1 and then build a cost function that scales:</p><pre class="snippet">g'(n) = 1 + alpha * (g(n) - 1)
</pre><p>If <code>alpha</code> is 0, then the modified cost function will always be 1. At this setting, terrain costs are completely ignored, and A* works at the level of simple passable/unpassable grid spaces. If <code>alpha</code> is 1, then the original cost function will be used, and you get the full benefit of A*. You can set <code>alpha</code> anywhere in between.</p><p>You should also consider switching from the heuristic returning the <em>absolute</em> minimum cost to returning the <em>expected</em> minimum cost. For example, if most of your map is grasslands with a movement cost of 2 but some spaces on the map are roads with a movement cost of 1, then you might consider having the heuristic assume no roads, and return <code>2 * distance</code>.</p><p>The choice between speed and accuracy does not have to be global. You can choose some things dynamically based on the importance of having accuracy in some region of the map. For example, it may be more important to choose a good path near the current location, on the assumption that we might end up recalculating the path or changing direction at some point, so why bother being accurate about the faraway part of the path? Or perhaps it’s not so important to have the shortest path in a safe area of the map, but when sneaking past an enemy village, safety and quickness are essential.</p></div><div class="h2banner"><h2 id="scale"><a class="anchor" href="http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html#scale">#</a>Scale</h2></div><div class="topic"><p>A* computes <code>f(n) = g(n) + h(n)</code>. To add two values, those two values need to be at the same scale. If <code>g(n)</code> is measured in hours and <code>h(n)</code> is measured in meters, then A* is going to consider <code>g</code> or <code>h</code> too much or too little, and you either won’t get as good paths or you A* will run slower than it could.</p></div><div class="h2banner"><h2 id="exact-heuristics"><a class="anchor" href="http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html#exact-heuristics">#</a>Exact heuristics</h2></div><div class="topic"><p>If your heuristic is exactly equal to the distance along the optimal path, you’ll see A* expand very few nodes, as in the diagram shown in <a href="http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html#manhattan-distance">the next section</a>. What’s happening inside A* is that it is computing <code>f(n) = g(n) + h(n)</code> at every node. When <code>h(n)</code> exactly matches <code>g(n)</code>, the value of <code>f(n)</code> doesn’t change along the path. All nodes not on the right path will have a higher value of <code>f</code> than nodes that are on the right path. Since A* doesn’t consider higher-valued <code>f</code> nodes until it has considered lower-valued <code>f</code> nodes, it never strays off the shortest path.</p><h3 id="precomputed-exact-heuristic">Precomputed exact heuristic</h3><p>One way to construct an exact heuristic is to precompute the length of the shortest path between every pair of points. This is not feasible for most game maps. However, there are ways to approximate this heuristic:</p><ul><li>Fit a coarse grid on top of the fine grid. Precompute the shortest path between any pair of coarse grid locations.</li><li>Precompute the shortest path between any pair of <a href="http://theory.stanford.edu/~amitp/GameProgramming/MapRepresentations.html#waypoints">waypoints</a>. This is a generalization of the coarse grid approach.</li></ul><p>Then add in a heuristic <code>h'</code> that estimates the cost of going from any location to nearby waypoints. (The latter too can be precomputed if desired.) The final heuristic will be:</p><pre class="snippet">h(n) = h'(n, w1) + distance(w1, w2) + h'(w2, goal)
</pre><p>or if you want a better but more expensive heuristic, evaluate the above with all pairs <code>w1</code>, <code>w2</code> that are close to the node and the goal, respectively.</p><h3 id="linear-exact-heuristic">Linear exact heuristic</h3><p>In a special circumstance, you can make the heuristic exact without precomputing anything. If you have a map with no obstacles and no slow terrain, then the shortest path from the starting point to the goal should be a straight line.</p><p>If you’re using a simple heuristic (one which does not know about the obstacles on the map), it should match the exact heuristic. If it doesn’t, then you may have a problem with scale or the type of heuristic you chose.</p></div><div class="h2banner"><h2 id="heuristics-for-grid-maps"><a class="anchor" href="http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html#heuristics-for-grid-maps">#</a>Heuristics for grid maps</h2></div><div class="topic"><p><span id="S7"></span> On a grid, there are well-known heuristic functions to use.</p><p><strong>Use the distance heuristic that matches the allowed movement:</strong></p><ul><li>On a square grid that allows <strong>4 directions</strong> of movement, use Manhattan distance (L<sub>1</sub>).</li><li>On a square grid that allows <strong>8 directions</strong> of movement, use Diagonal distance (L<sub>∞</sub>).</li><li>On a square grid that allows <strong>any direction</strong> of movement, you might or might not want Euclidean distance (L<sub>2</sub>). If A* is finding paths on the grid but you are allowing movement not on the grid, you may want to consider <a href="http://www.redblobgames.com/pathfinding/grids/algorithms.html">other representations of the map</a>.</li><li>On a hexagon grid that allows <strong>6 directions</strong> of movement, use Manhattan distance <a href="http://www.redblobgames.com/grids/hexagons/#distances">adapted to hexagonal grids</a>.</li></ul><p>Multiply the distance in steps by the minimum cost for a step. For example, if you’re measuring in meters, the distance is 3 squares, and each square is 15 meters, then the heuristic would return 3 ⨉ 15 = 45 meters. If you’re measuring in time, the distance is 3 squares, and each square takes at least 4 minutes to cross, then the heuristic would return 3 ⨉ 4 = 12 minutes. The units (meters, minutes, etc.) returned by the heuristic should match the units used by the cost function.</p><h3 id="manhattan-distance">Manhattan distance</h3><p>The standard heuristic for a square grid is the <a href="http://en.wikipedia.org/wiki/Taxicab_geometry">Manhattan distance</a>. Look at your cost function and find the minimum cost <code>D</code> for moving from one space to an adjacent space. <em>In the simple case, you can set <code>D</code> to be 1.</em> The heuristic on a square grid where you can move in 4 directions should be <code>D</code> times the Manhattan distance:</p><pre class="snippet">function heuristic(node) =
 &nbsp;  dx = abs(node.x - goal.x)
 &nbsp;  dy = abs(node.y - goal.y)
 &nbsp;  return D * (dx + dy)
</pre><p>How do you pick D? Use a scale that matches your cost function. For the best paths, and an “admissible” heuristic, set D to the lowest cost between adjacent squares. In the absence of obstacles, and on terrain that has the minimum movement cost D, moving one step closer to the goal should <em>increase <code>g</code></em> by D and <em>decrease <code>h</code></em> by D. When you add the two, <code>f</code> (which is set to <code>g +
h</code>) will stay the same; that’s a sign that the heuristic and cost function scales match. You can also give up optimal paths to make A* run faster by increasing D, or by decreasing the ratio between the lowest and highest edge costs.</p><div class="figure"><img width="526" height="226" src="./Heuristics_files/manhattan.png" alt=""></div><p>(Note: the above image has a <a href="http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html#breaking-ties">tie-breaker</a> added to the heuristic.)</p><h3 id="diagonal-distance">Diagonal distance</h3><p>If your map allows diagonal movement you need a different heuristic. The Manhattan distance for (4 east, 4 north) will be 8⨉D. However, you could simply move (4 northeast) instead, so the heuristic should be 4⨉D2, where D2 is the cost of moving diagonally.</p><div class="figure"><img width="526" height="226" src="./Heuristics_files/diagonal.png" alt=""></div><pre class="snippet">function heuristic(node) =
 &nbsp;  dx = abs(node.x - goal.x)
 &nbsp;  dy = abs(node.y - goal.y)
 &nbsp;  return D * (dx + dy) + (D2 - 2 * D) * min(dx, dy)
</pre><p>Here we compute the number of steps you take if you can’t take a diagonal, then subtract the steps you save by using the diagonal. There are <code>min(dx, dy)</code> diagonal steps, and each one costs <code>D2</code> but saves you <code>2⨉D</code> non-diagonal steps.</p><p>When D = 1 and D2 = 1, this is called the <a href="http://en.wikipedia.org/wiki/Chebyshev_distance">Chebyshev distance</a>. When D = 1 and D2 = sqrt(2), this is called the <em>octile distance</em>.</p><p><a href="http://www.policyalmanac.org/games/heuristics.htm">Patrick Lester has a different way of writing this heuristic</a>, using an explicit cases for <code>dx &gt; dy</code> vs <code>dx &lt; dy</code>. The above code has the same test but it’s hidden inside the call to <code>min</code>.</p><h3 id="euclidean-distance">Euclidean distance</h3><p>If your units can move at any angle (instead of grid directions), then you should probably use a straight line distance:</p><pre class="snippet">function heuristic(node) =
 &nbsp;  dx = abs(node.x - goal.x)
 &nbsp;  dy = abs(node.y - goal.y)
 &nbsp;  return D * sqrt(dx * dx + dy * dy)
</pre><p>However, if this is the case, then you may have trouble with using A* directly because the cost function <code>g</code> will not match the heuristic function <code>h</code>. Since Euclidean distance is shorter than Manhattan or diagonal distance, you will still get shortest paths, but A* will take longer to run:</p><div class="figure"><img width="526" height="226" src="./Heuristics_files/euclidean.png" alt=""></div><h3 id="euclidean-distance-squared">Euclidean distance, squared</h3><p>I’ve seen several A* web pages recommend that you avoid the expensive square root in the Euclidean distance by using distance-squared:</p><pre class="snippet">function heuristic(node) =
 &nbsp;  dx = abs(node.x - goal.x)
 &nbsp;  dy = abs(node.y - goal.y)
 &nbsp;  return D * (dx * dx + dy * dy)
</pre><p><strong>Do not do this!</strong> This definitely runs into the scale problem. The scale of <code>g</code> and <code>h</code> need to match, because you’re adding them together to form <code>f</code>. When A* computes <code>f(n) = g(n) + h(n)</code>, the square of distance will be much higher than the cost <code>g</code> and you will end up with an overestimating heuristic. For longer distances, this will approach the extreme of <code>g(n)</code> not contributing to <code>f(n)</code>, and A* will degrade into Greedy Best-First-Search:</p><div class="figure"><img width="526" height="376" src="./Heuristics_files/best-first-search-trap.png" alt=""></div><p>To attempt to fix this you can scale the heuristic down. However, then you run into the opposite problem: for shorter distances, the heuristic will be too small compared to <code>g(n)</code> and A* will degrade into Dijkstra’s algorithm.</p><p>If, after profiling, you find the cost of the square root is significant, either use a fast square root approximation with Euclidean distance or use the diagonal distance as an approximation to Euclidean.</p><h3 id="multiple-goals">Multiple goals</h3><p>If you want to search for <em>any</em> of several goals, construct a heuristic <code>h'(x)</code> that is the minimum of <code>h1(x), h2(x),
  h3(x), ...</code> where <code>h1, h2, h3</code> are heuristics to each of the nearby spots.</p><p>If you want to search for spot near a single goal, ask A* search to find a path to the center of the goal area. While processing nodes from the OPEN set, exit when you pull a node that is near enough.</p><h3 id="breaking-ties">Breaking ties</h3><p>In some grid maps there are many paths with the same length. For example, in flat areas without variation in terrain, using a grid will lead to many equal-length paths. A* might explore all the paths with the same <code>f</code> value, instead of only one.</p><div class="figure"><img width="491" height="351" src="./Heuristics_files/tie-breaking-off.png" alt=""><br> Ties in <code>f</code> values.<br></div><p>The quick hack to work around this problem is to either adjust the <code>g</code> or <code>h</code> values. The tie breaker needs to be deterministic with respect to the vertex (<em>i.e.,</em> it shouldn’t be a random number), and it needs to make the <code>f</code> values differ. Since A* sorts by <code>f</code> value, making them different means only one of the “equivalent” <code>f</code> values will be explored.</p><p>One way to break ties is to nudge the scale of <code>h</code> slightly. If we scale it downwards, then <code>f</code> will increase as we move towards the goal. Unfortunately, this means that A* will prefer to expand vertices close to the starting point instead of vertices close to the goal. We can instead scale <code>h</code> upwards slightly (even by 0.1%). A* will prefer to expand vertices close to the goal.</p><pre class="snippet">heuristic *= (1.0 + p)
</pre><p>The factor <code>p</code> should be chosen so that <code>p &lt;</code><em>(minimum cost of taking one step)</em><code>/</code><em>(expected maximum path length)</em>. Assuming that you don’t expect the paths to be more than 1000 steps long, you can choose p = 1/1000. (Note that this slightly breaks “admissibility” of the heuristic but in games it almost never matters.) The result of this tie-breaking nudge is that A* explores far less of the map than previously:</p><div class="figure"><img width="491" height="351" src="./Heuristics_files/tie-breaking-scale-1.png" alt=""><br> Tie-breaking scaling added to heuristic.<br></div><p>When there are obstacles of course it still has to explore to find a way around them, but note that after the obstacle is passed, A* explores very little:</p><div class="figure"><img width="491" height="351" src="./Heuristics_files/tie-breaking-scale-2.png" alt=""><br> Tie-breaking scaling added to heuristic, works nicely with obstacles.<br></div><p>Steven van Dijk suggests that a more straightforward way to do this would to pass <code>h</code> to the comparison function. When the <code>f</code> values are equal, the comparison function would break the tie by looking at <code>h</code>.</p><p>Another way to break ties is to add a deterministic random number to the heuristic or edge costs. (One way to choose a deterministic random number is to compute a hash of the coordinates.) This breaks more ties than adjusting <code>h</code> as above. Thanks to Cris Fuhrman for suggesting this.</p><p>A different way to break ties is to prefer paths that are along the straight line from the starting point to the goal:</p><pre class="snippet">dx1 = current.x - goal.x
dy1 = current.y - goal.y
dx2 = start.x - goal.x
dy2 = start.y - goal.y
cross = abs(dx1*dy2 - dx2*dy1)
heuristic += cross*0.001
</pre><p>This code computes the vector cross-product between the start to goal vector and the current point to goal vector. When these vectors don’t line up, the cross product will be larger. The result is that this code will give some slight preference to a path that lies along the straight line path from the start to the goal. When there are no obstacles, A* not only explores less of the map, the path looks very nice as well:</p><div class="figure"><img width="491" height="351" src="./Heuristics_files/tie-breaking-cross-1.png" alt=""><br> Tie-breaking cross-product added to heuristic, produces pretty paths.<br></div><p>However, because this tie-breaker prefers paths along the straight line from the starting point to the goal, weird things happen when going around obstacles (note that the path is still optimal; it will look strange):</p><div class="figure"><img width="491" height="351" src="./Heuristics_files/tie-breaking-cross-2.png" alt=""><br> Tie-breaking cross-product added to heuristic, less pretty with obstacles.<br></div><p>To interactively explore the improvement from this tie breaker, see <a href="http://www.ccg.leeds.ac.uk/people/j.macgill/xaStar/">James Macgill’s A* applet</a> [or try <a href="http://www.vision.ee.ethz.ch/~cvcourse/astar/AStar.html">this mirror</a> or <a href="http://web.archive.org/web/www.ccg.leeds.ac.uk/james/aStar/">this mirror</a>]. Use “Clear” to clear the map, and choose two points on opposite corners of the map. When you use the “Classic A*” method, you will see the effect of ties. When you use the “Fudge” method, you will see the effect of the above cross product added to the heuristic.</p><p>Yet another way to break ties is to carefully construct your A* priority queue so that <em>new</em> insertions with a specific <code>f</code> value are always ranked better (lower) than <em>old</em> insertions with the same <code>f</code> value.</p><p>And yet another way to break ties on grids is to minimize turns. The change in x,y from the <em>parent</em> to the <em>current</em> node tells you what direction you were moving in. For all edges being considered from <em>current</em> to <em>neighbor</em>, if the change in x,y is different than the one from parent to current, then add a small penalty to the movement cost.</p><p><strong>The above modifications to the heuristic are a “band aid” fix to an underlying inefficiency.</strong> Ties occur when there are lots of paths that are equally good, leading to a large number of nodes to explore. Consider ways to “work smarter, not harder”:</p><ul><li>Alternate <a href="http://theory.stanford.edu/~amitp/GameProgramming/MapRepresentations.html">map representations</a> can solve the problem by <strong>reducing the number of nodes in the graph</strong>. Collapsing multiple nodes into one, or by remove all but the important nodes. <a href="http://aigamedev.com/open/tutorial/symmetry-in-pathfinding/">Rectangular Symmetry Reduction</a> is a way to do this on square grids; also look at “framed quad trees”. <a href="http://theory.stanford.edu/~amitp/GameProgramming/MapRepresentations.html#hierarchical">Hierarchical pathfinding</a> uses a high level graph with few nodes to find most of the path, then a low level graph with more nodes to refine the path.</li><li>Some approaches leave the number of nodes alone but <strong>reduce the number of nodes visited</strong>. <a href="http://aigamedev.com/open/tutorial/symmetry-in-pathfinding/">Jump Point Search</a> skips over large areas of nodes that would contain lots of ties; it’s designed for square grids. <a href="http://theory.stanford.edu/~amitp/GameProgramming/MapRepresentations.html#skip-links">Skip links</a> add “shortcut” edges that skip over areas of the map. The <a href="http://home1.stofanet.dk/breese/papers.html">AlphA* algorithm</a> adds some depth-first searching to the usual breadth-first behavior of A*, so that it can explore a single path instead of processing all of them simultaneously.</li><li><a href="http://cswww.essex.ac.uk/cig/2005/papers/p1039.pdf">Fringe Search (PDF)</a> solves the problem instead by <strong>making node processing fast</strong>. Instead of keeping the OPEN set sorted and visiting nodes one at a time, it processes nodes in batches, expanding only the nodes that have low f-values. This is related to the <a href="http://theory.stanford.edu/~amitp/GameProgramming/ImplementationNotes.html#hot-queues">HOT queues</a> approach.</li></ul></div><div class="astar-nav">This is page 2 of 13 of <a href="http://theory.stanford.edu/~amitp/GameProgramming/index.html">Amit’s Thoughts on Pathfinding</a>.<br><span>←Back: <a rel="prev" href="http://theory.stanford.edu/~amitp/GameProgramming/AStarComparison.html">Introduction to A*</a></span><span>Up: <a href="http://theory.stanford.edu/~amitp/GameProgramming/index.html">Table of contents</a></span><span>Next: <a rel="next" href="http://theory.stanford.edu/~amitp/GameProgramming/ImplementationNotes.html">Implementation</a>→</span></div></div><div class="divider"></div><div class="divider-disqus" style="font-size:large">
            Email me at
            
            <a class="email" href="mailto:redblobgames@gmail.com">redblobgames@gmail.com</a>,
                or tweet to <a href="https://twitter.com/redblobgames">@redblobgames</a>,
              
            or post a public comment:
          </div><div class="comments" role="complementary"><div id="disqus_thread" class="main"><iframe id="dsq-app1" name="dsq-app1" allowtransparency="true" frameborder="0" scrolling="no" tabindex="0" title="Disqus" width="100%" src="./Heuristics_files/saved_resource.html" style="width: 1px !important; min-width: 100% !important; border: none !important; overflow: hidden !important; height: 7991px !important;" horizontalscrolling="no" verticalscrolling="no"></iframe></div><script>
              (function() {
              var dsq = document.createElement('script');
              dsq.type = 'text/javascript'; dsq.async = true;
              
                  dsq.src = '//blobs.disqus.com/embed.js';
                
              if (document.location.hostname != 'localhost') (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
              })();
            </script><noscript>&lt;a href="//blobs.disqus.com/?url=ref"&gt;View the discussion thread.&lt;/a&gt;</noscript></div><div class="footer" role="contentinfo"><div style="float:left;width:300px;margin-right:40px"><address>
		  Copyright © 2016
                  <span class="vcard"><a rel="author home copyright" class="url fn n" href="http://www-cs-students.stanford.edu/~amitp/"><span class="given-name"> Amit </span><span class="family-name"> Patel</span></a></span></address></div><div style="text-align:right">
	    &nbsp;From <a href="http://www.redblobgames.com/">Red Blob Games</a><br>I started writing this in 1997; last modified: 16 Sep 2016</div><br style="clear:both"><!-- Start of counters --><script><!--
                  var sc_project=417499;
                  var sc_invisible=1;
                  var sc_security="";
(function() {
      var script = document.createElement('script');
      script.type = 'text/javascript'; script.async = true;
      script.src = 'http://statcounter.com/counter/counter_xhtml.js';
      if (document.location.hostname != 'localhost') document.getElementsByTagName('body')[0].appendChild(script);
  })();
                //--></script><noscript>&lt;div class="statcounter"&gt;&lt;a class="statcounter" href="http://statcounter.com/"&gt;&lt;img class="statcounter" src="http://c.statcounter.com/417499/0//1/" alt=""&gt;&lt;/a&gt;&lt;/div&gt;</noscript><script>
var _gap = _gap || [];
_gap.push(['_setAccount', 'UA-79181-1']);
_gap.push(['_setDomainName', 'stanford.edu']);
_gap.push(['_setCookiePath', '/~amitp']);
_gap.push(['_setAllowLinker', true]);
_gap.push(['_trackPageview']);
_gap.push(['_gapTrackBounceViaTime', 30]);
_gap.push(['_gapTrackBounceViaScroll', 25]);
_gap.push(['_gapTrackReads', 60, 10]);
_gap.push(['_gapTrackLinkClicks']);
if (document.location.hostname != 'localhost') (function() {
    var gap = document.createElement('script');
    gap.async = true;
    gap.type = 'text/javascript';
    gap.src = '/~amitp/gap.min.js';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gap, s);
})();
              </script><!-- End of counters --></div><script type="text/javascript" async="" src="http://statcounter.com/counter/counter_xhtml.js"></script>
<iframe style="display: none;" src="./Heuristics_files/saved_resource(1).html"></iframe></body></html>