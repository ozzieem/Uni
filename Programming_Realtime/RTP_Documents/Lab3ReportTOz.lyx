#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{listings}
\usepackage{color}
\usepackage{textcomp}
\definecolor{listinggray}{gray}{0.9}
\definecolor{lbcolor}{rgb}{0.9,0.9,0.9}
\lstset{
backgroundcolor=\color{lbcolor},
tabsize=4,
rulecolor=,
language=C,
        basicstyle=\scriptsize,
        upquote=true,
        aboveskip={1.5\baselineskip},
        columns=fixed,
        keywordstyle=\color{blue},
        stringstyle=\color{red},
        commentstyle=\color{green},
        morecomment=[l][\color{magenta}]{\#}
        showstringspaces=false,
        extendedchars=true,
        breaklines=true,
        prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
        frame=single,
        showtabs=false,
        showspaces=false,
        showstringspaces=false,
        identifierstyle=\ttfamily,
        keywordstyle=\color[rgb]{0,0,1},
        commentstyle=\color[rgb]{0.133,0.545,0.133},
        stringstyle=\color[rgb]{0.627,0.126,0.941},
}

\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=red,
    urlcolor=green
}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Lab 3 Report
\end_layout

\begin_layout Author
Tobias L & Ã–zgun M (Group 5)
\end_layout

\begin_layout Standard
The purpose of this lab was to learn how to work with POSIX-threads and
 setting the priority of the threads.
 The main task was to make a thread sleep without using the conventional
 sleep-functions in time.h such as clock_nanosleep() and sleep().
 
\end_layout

\begin_layout Section
busy_wait (A)
\end_layout

\begin_layout Standard
To put a delay on a thread without using these particular functions a spinning
 busywait-function was created to make the processor artifically be delayed,
 but still execute other tasks.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

void busy_wait(const long nsec)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	long diffns = 0;
\end_layout

\begin_layout Plain Layout

	int diffs = 0;
\end_layout

\begin_layout Plain Layout

	struct timespec ts1, ts2;
\end_layout

\begin_layout Plain Layout

	clock_gettime(0, &ts1);
\end_layout

\begin_layout Plain Layout

	clock_gettime(0, &ts2);
\end_layout

\begin_layout Plain Layout

	while (diffns < nsec)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		clock_gettime(0, &ts2);
\end_layout

\begin_layout Plain Layout

		diffns = ts2.tv_nsec - ts1.tv_nsec;
\end_layout

\begin_layout Plain Layout

		diffs = ts2.tv_sec - ts1.tv_sec;
\end_layout

\begin_layout Plain Layout

		diffns += diffs * BILLION;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As one can see from the algorithm above, we have a parameter which takes
 a long argument.
 It's const because as the program was running the variable was for some
 reason changed during execution time.
 The while loop is running for as long as the time-difference is less than
 the argument nanoseconds.
 In the while-loop a difference check is running to compare the two timers
 and how long they've progressed through the timer.
 This makes an artificial 
\begin_inset Quotes eld
\end_inset

sleep
\begin_inset Quotes erd
\end_inset

 but instead of stopping the thread it's running an unnecessary process,
 which is an unnecessary strain on the CPU.
\end_layout

\begin_layout Section
Two tasks with priorities (B)
\end_layout

\begin_layout Standard
In this section of the lab, there were a few observations that had to be
 made in regards to thread-creation and priority assignment.
 Task1 was controlling the 1st LED and Task2 was controlling the 2nd LED.
\end_layout

\begin_layout Subsection
Creating two tasks at different times (B.1)
\end_layout

\begin_layout Subsubsection
First create Task1 and then Task2
\end_layout

\begin_layout Subsubsection
First create Task2 and then Task1
\end_layout

\begin_layout Standard
Creating one or the other task before the other doesn't make any difference.
 
\end_layout

\begin_layout Subsection
Priority assignment I (B.2)
\end_layout

\begin_layout Standard
Task1 in this test was using the busy_wait-function to delay the processor,
 while Task2 was using a normal nanosleep-function.
 The observation produced the following results:
\end_layout

\begin_layout Subsubsection
Creating Task1 before Task2
\end_layout

\begin_layout Paragraph
High priority
\end_layout

\begin_layout Standard
Task1 runs and finish, then Task2 starts and finish
\end_layout

\begin_layout Paragraph
Low priority
\end_layout

\begin_layout Standard
Task1 starts and Task2 starts estimated 0.5 seconds after.
 The program alterantes between the tasks till they return.
 The reason they're alternating is because of nanosleep in Task2.
 While Task2 sleeps, it allows Task1 to resume until Task2 is awake.
\end_layout

\begin_layout Subsubsection
Creating Task2 before Task1
\end_layout

\begin_layout Paragraph
High priority
\end_layout

\begin_layout Standard
Task1 and Task2 starts together.
 The program alternates between the tasks till they return.
 The reason of the alteranting is because of nanosleep in Task2.
 While Task2 sleeps, it allows Task1 to resume until Task2 is awake.
\end_layout

\begin_layout Paragraph
Low priority
\end_layout

\begin_layout Standard
Task2 starts and instantly pauses.
 Task1 runs and finish.
 Task2 resumes and finish.
\end_layout

\begin_layout Subsection
Priority assignment II (B.3)
\end_layout

\begin_layout Standard
Task1 and Task2 were both using the busy_wait-function in this test.
 The observation produced the following results:
\end_layout

\begin_layout Subsubsection
Higher priority to Task1 
\end_layout

\begin_layout Standard
Task1 starts and doesn't let Task2 start before Task1 is done.
\end_layout

\begin_layout Subsubsection
Higher priority to Task2
\end_layout

\begin_layout Standard
Task1 starts.
 Task2 starts and interupts/pauses Task1.
 (Sometimes Task2 interupted Task1 when the LED was on, so Task1 continued
 to shine while Task2 was running.
 This is caused by the higher priority for Task2.
 When Task1 was just about to preemptive, Task2 started before it was able
 to shut down.
 So it would run parallell to Task1.).
 Task2 runs until it reaches its finish time THEN Task1 continues to run.
\end_layout

\begin_layout Section
Three tasks with synchronization (C)
\end_layout

\begin_layout Standard
In this exercise three tasks had to be made.
 Two tasks (Task1 and Task2) were going to be from the previous exercises
 and Task3 was going to read in a value from terminal.
 The value that was read was going to determine the brightness of the LEDs
 that was controlled by Task1 and Task2 respectively.
 Instead of reading a float value, a struct was created which the attributes
 LED-number and the value of the brightness.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

typedef struct
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	int led;
\end_layout

\begin_layout Plain Layout

	int brightness;
\end_layout

\begin_layout Plain Layout

} Light;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The value that is entered is still in the format of n.m where n is the led-number
 and m is the brightness-value.
\end_layout

\begin_layout Standard
Since the threads all share the same global variable it had to be locked
 by a global mutex, to prevent the threads from accessing the variable at
 the same time.
 Testing this program at the end caused some unexpected errors with the
 thread-cancel - functions which was solved by entering 
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
handle SIG32 nostop
\end_layout

\end_inset

 to prevent the program from breaking in the middle of closing the program.
\end_layout

\begin_layout Standard
Task3 was reading a value by scanf.
 The read value would only put into the global variable if it met the conditions
 for execution, otherwise it would just stay in the local variable until
 it was overwritten by the next input.
 The tasks that were reading the value of the global variable also had a
 mutex lock, when it was reading and had met the conditions for proceeding.
 One optimisation that could be done is to check if the condition is fulfilled
 before going into the specific function that runs the LEDs.
 The code can be seen in separate files.
\end_layout

\end_body
\end_document
