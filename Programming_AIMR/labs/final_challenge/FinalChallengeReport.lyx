#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass report
\begin_preamble
% DO NOT ALTER THIS PREAMBLE!!!
%
%This preamble is designed to ensure that the document prints
% out as advertised. If you mess with this preamble,
% parts of the document may not print out as expected.  If you
% have problems LaTeXing this file, please contact 
% the documentation team
% email: lyx-docs@lists.lyx.org

\usepackage{ifpdf} % part of the hyperref bundle
\ifpdf % if pdflatex is used
     % set fonts for nicer pdf view
     \IfFileExists{lmodern.sty}{\usepackage{lmodern}}{}
\fi % end if pdflatex is used

\usepackage{tikz}
\usetikzlibrary{mindmap}
\usepackage{attachfile2}
\usepackage{embedfile}
\usepackage{hypgotoe}
\usepackage{verbatim}
\usepackage{adjustbox}
%\embedfile{Intro.pdf}
\usepackage{tocloft}
\renewcommand{\cftdot}{}
\usepackage{minitoc}
\definecolor{green}{RGB}{0, 180, 0}
\definecolor{cyan}{RGB}{0, 180, 180}
\definecolor{yellow}{RGB}{102,51,0}
\definecolor{bluekeywords}{rgb}{0.13,0.13,1}
\definecolor{greencomments}{rgb}{0,0.5,0}
\definecolor{redstrings}{rgb}{0.9,0,0}

\usepackage{listings}
\usepackage{courier}
\lstset{language=[Visual]C++,
showspaces=false,
showtabs=false,
breaklines=true,
showstringspaces=false,
breakatwhitespace=true,
escapeinside={(*@}{@*)},
commentstyle=\color{greencomments},
keywordstyle=\color{bluekeywords},
stringstyle=\color{redstrings},
basicstyle=\ttfamily,
tabsize=3
}

\lstloadlanguages{% Check Dokumentation for further languages ...
%[Visual]Basic
%Pascal
%C
C++,
%XML
%HTML
Java
}
%\DeclareCaptionFont{blue}{\color{blue}}

%\captionsetup[lstlisting]{singlelinecheck=false, labelfont={blue}, textfont={blue}}
\usepackage{caption}
\DeclareCaptionFont{white}{\color{white}}
\DeclareCaptionFormat{listing}{\colorbox[cmyk]{0.43, 0.35, 0.35,0.01}{\parbox{\textwidth}{\hspace{15pt}#1#2#3}}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white, singlelinecheck=false, margin=0pt, font={bf,footnotesize}}

% Style definition file generated by highlight 3.13, http://www.andre-simon.de/

\begin{comment}
% Highlighting theme: Acid
\usepackage{marvosym}
\newcommand{\hlstd}[1]{\textcolor[rgb]{0,0,0}{#1}}
\newcommand{\hlnum}[1]{\textcolor[rgb]{0.5,0,0.5}{\bf{#1}}}
\newcommand{\hlesc}[1]{\textcolor[rgb]{1,0,1}{\bf{#1}}}
\newcommand{\hlstr}[1]{\textcolor[rgb]{0.65,0.52,0}{#1}}
\newcommand{\hlpps}[1]{\textcolor[rgb]{0,0,1}{#1}}
\newcommand{\hlslc}[1]{\textcolor[rgb]{0.95,0.47,0}{#1}}
\newcommand{\hlcom}[1]{\textcolor[rgb]{1,0.5,0}{#1}}
\newcommand{\hlppc}[1]{\textcolor[rgb]{0,0.5,0.75}{\bf{#1}}}
\newcommand{\hlopt}[1]{\textcolor[rgb]{1,0,0.5}{\bf{#1}}}
\newcommand{\hlipl}[1]{\textcolor[rgb]{0.62,0.36,1}{#1}}
\newcommand{\hllin}[1]{\textcolor[rgb]{0.19,0.19,0.19}{#1}}
\newcommand{\hlkwa}[1]{\textcolor[rgb]{0.73,0.47,0.47}{\bf{#1}}}
\newcommand{\hlkwb}[1]{\textcolor[rgb]{0.5,0.5,0.75}{\bf{#1}}}
\newcommand{\hlkwc}[1]{\textcolor[rgb]{0,0.5,0.75}{#1}}
\newcommand{\hlkwd}[1]{\textcolor[rgb]{0,0.27,0.4}{#1}}
\definecolor{bgcolor}{rgb}{0.93,0.93,0.93}
\end{comment}

% Highlighting theme: Visual Studio IDE
\newcommand{\hlstd}[1]{\textcolor[rgb]{0,0,0}{#1}}
\newcommand{\hlnum}[1]{\textcolor[rgb]{0,0,0}{#1}}
\newcommand{\hlesc}[1]{\textcolor[rgb]{0.64,0.08,0.08}{#1}}
\newcommand{\hlstr}[1]{\textcolor[rgb]{0.64,0.08,0.08}{#1}}
\newcommand{\hlpps}[1]{\textcolor[rgb]{0,0,1}{#1}}
\newcommand{\hlslc}[1]{\textcolor[rgb]{0,0.5,0}{#1}}
\newcommand{\hlcom}[1]{\textcolor[rgb]{0,0.5,0}{#1}}
\newcommand{\hlppc}[1]{\textcolor[rgb]{0,0,1}{#1}}
\newcommand{\hlopt}[1]{\textcolor[rgb]{0,0,0}{#1}}
\newcommand{\hlipl}[1]{\textcolor[rgb]{0.64,0.08,0.08}{#1}}
\newcommand{\hllin}[1]{\textcolor[rgb]{0.17,0.57,0.69}{#1}}
\newcommand{\hlkwa}[1]{\textcolor[rgb]{0,0,1}{#1}}
\newcommand{\hlkwb}[1]{\textcolor[rgb]{0,0,1}{#1}}
\newcommand{\hlkwc}[1]{\textcolor[rgb]{0.17,0.57,0.69}{#1}}
\newcommand{\hlkwd}[1]{\textcolor[rgb]{0,0,0}{#1}}
\definecolor{bgcolor}{rgb}{1,1,1}

\cftsetindents{part}{-0.325in}{0.25in}

\renewcommand\thesection{\arabic{section}}
\renewcommand\thesubsection{\thesection.\arabic{subsection}}
\end_preamble
\use_default_options true
\begin_modules
multicol
sectionbox
theorems-ams
eqs-within-sections
figs-within-sections
algorithm2e
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 2
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title

\series bold
\shape smallcaps
\size huge
Artificial Intelligence in Mobile Robots
\series default
\shape default
\size default

\begin_inset Newline newline
\end_inset


\shape smallcaps
\size larger
Final challenge
\end_layout

\begin_layout Author
By
\emph on
 Tobias L 
\emph default
&
\emph on
 Özgun 
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\emph default
Professor 
\emph on
Alessandro Saffiotti
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\size normal
\emph default
Lab Assistant
\emph on
 Ali Abdul Khaliq
\size default

\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\emph default
Örebro University
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard

\size larger
\bar under
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\size larger
\bar under
Student info
\end_layout

\end_inset


\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout

\size larger
\bar under
Student information
\end_layout

\begin_layout Plain Layout
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "50text%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
Tobias Lindvall
\end_layout

\begin_layout Plain Layout
870603-6657
\end_layout

\begin_layout Plain Layout
tobiaslindwall@gmail.com
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "50text%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
Özgun Mirtchev
\end_layout

\begin_layout Plain Layout
920321-2379
\end_layout

\begin_layout Plain Layout
ozgun.mirtchev@gmail.com
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\size default
\bar default

\begin_inset Float table
placement b
wide false
sideways false
status open

\begin_layout Plain Layout

\size largest
Report handed in: 2016-10-28
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Overview
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
-State lab objectives, and overview.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the final challenge the main task is to write a robot navigation program,
 using every system that was completed in the previous labs, into a single
 system to be able to control the ePuck using the Hybrid architecture, a
 combination of the Sense-Plan (planning) and Reactive (fuzzy rules) architectur
es.
 
\end_layout

\begin_layout Standard
Given tasks are to make the ePuck move to a target position, implement an
 obstacle detection procedure which updates the map accordingly and re-plan
 if the ePuck was following a path.
 Other tasks are to compare path-finding algorithms and implement a different
 path-generation and path-following procedure as called as 
\begin_inset Quotes eld
\end_inset

distance map generation & gradient following
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
In each part of this document every task that was completed will be presented
 with problems and possible solutions.
 After each implementation, a testing part which shows how the systems were
 tested and possible conclusions from the tests.
 
\end_layout

\begin_layout Standard
Further discussions will take place in the discussion part.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Implementing Fuzzy Rule-based Control for Obstacle Avoidance
\end_layout

\begin_layout Section
Task 
\end_layout

\begin_layout Standard
The purpose of this task is to make the ePuck able to re-actively reach
 a specific goal while avoiding obstacles in an unknown environment.
\end_layout

\begin_layout Standard
More specifically what is needed to be done is a merge of two functions
 from the previous labs.
 One function is called Goto() which makes the ePuck move to a specified
 target.
 The second function is called AvoidObstacles() which enables the ePuck
 to be able to avoid obstacles through the use of its IR-sensors and the
 use of predicate rules.
\end_layout

\begin_layout Standard
There were a couple of things that had to be kept in mind while solving
 this problem:
\end_layout

\begin_layout Itemize
Threshold values for detecting obstacles with IR-sensors had to be set and
 tuned.
\end_layout

\begin_layout Itemize
Movement and rotation speed to be used.
\end_layout

\begin_layout Itemize
Monolithic or modular approach
\end_layout

\begin_layout Standard
Implementing the fuzzy rule-based control was done with help from pseudo
 code that was given in lecture slides.
 The control takes the coordinates of where the ePuck should end up in the
 environment as input.
 
\end_layout

\begin_layout Standard
To control the ePuck in a fuzzy way and make it head towards the goal, fuzzy
 predicates were used.
 These predicates represents the relationship between the ePuck's current
 position and the goal.
 
\end_layout

\begin_layout Standard
To make the ePuck avoid obstacles on it's way to the goal, another set of
 fuzzy predicates was used.
 These predicates are calculated from output values of the IR-sensors on
 the ePuck.
 When calculated, they describe if there are any obstacles present, in what
 direction and how far away these possible obstacles are.
\end_layout

\begin_layout Standard
When these predicates are calculated, they are the basis for setting the
 rotation and movement speed of the ePuck.
 The IR tuning could depend on the precision and eventual noise in the IR-sensor
s.
\end_layout

\begin_layout Standard
The merging of the two functions was done by using the Monolithic approach.
\end_layout

\begin_layout Section
Conclusions / Tests
\end_layout

\begin_layout Standard
When testing with the provided rules from the lectures, the ePuck was unable
 to find its goal in most situations since there simply weren't enough rules
 for all possible states, so there would be a lot of empty fuzzy sets, causing
 the speed of the wheels to not be set and the ePuck to get stuck.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "BasicFuzzy"

\end_inset

 illustrates this pretty well.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename epuck_trajectory_pics/AlessandroFuzzyAvoidMap1.png
	lyxscale 30
	scale 14
	scaleBeforeRotation

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Gets stuck at wall (
\begin_inset CommandInset href
LatexCommand href
name "video"
target "https://drive.google.com/open?id=0B1G7rZ1HC6TpbW1pOWZqWGpaUWs"

\end_inset

)
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename epuck_trajectory_pics/AlessandroFuzzyAvoidMap3.png
	lyxscale 30
	scale 14
	scaleBeforeRotation

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Fails at moving out of the obstacle setup (
\begin_inset CommandInset href
LatexCommand href
name "video"
target "https://drive.google.com/open?id=0B1G7rZ1HC6TpM2oxb05KNThCWFE"

\end_inset

)
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Basic Fuzzy Avoid Rules
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "BasicFuzzy"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Of course the path planning and the tracking functions were implemented
 since before and can be found in the appendix: 
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperlink{FollowPath}{Follow Path}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperlink{Track}{Track}
\end_layout

\end_inset


\end_layout

\begin_layout Part
Updating Map with Obstacles
\end_layout

\begin_layout Section
Task 
\end_layout

\begin_layout Standard
The purpose of updating the map with obstacles is to get a correct model
 of the environment which makes upcoming searches and planning better.
 
\end_layout

\begin_layout Standard
Problems that had to be solved to be able to update the map with new obstacles:
\end_layout

\begin_layout Itemize
Which on-board IR sensors should be used?
\end_layout

\begin_layout Itemize
How far from the ePuck is the detected obstacle?
\end_layout

\begin_layout Itemize
In which grid node is the detected obstacle?
\end_layout

\begin_layout Itemize
How to see the difference between a new obstacle and one that is already
 in the map?
\end_layout

\begin_layout Standard
To make the ePuck able to detect obstacles, four of the on-board IR sensors
 values (one left, one right and two forward) are read.
 When read, they are verified to see if any object is nearby.
 If there is, the distance to the obstacle is calculated which is used to
 see in which map cell the object is.
 If the cell already contains an obstacle or a wall piece, no action is
 taken.
 Otherwise if the cell is empty, the cell is updated with information about
 containing the obstacle.
 If this updated cell happens to be in the planned route for the ePuck,
 the current tracking will abort and a new plan will be made.
\end_layout

\begin_layout Standard
To make the distance to the obstacle from the ePuck be more precise, each
 IR-sensor's value was measured in length.
 Doing this, enough data was provided to be able to generate a graph (Figure
 
\begin_inset CommandInset ref
LatexCommand ref
reference "DistanceGraphFigure"

\end_inset

) in MATLAB, and a formula to use.
 This formula would be used to convert the values of the IR-sensors into
 millimeters in the program, making the calculations even more accurate.
 The formula is as follows: 
\begin_inset Formula $8.7*10^{-7}*IRvalue^{2}-0.0087*IRvalue+23*F$
\end_inset

 where 
\begin_inset Formula $F$
\end_inset

 is a factor that was added to try and compensate for the differentiating
 values of the IR-sensors.
 In example, if the value of IR-sensor1 is at 500 with the distance to the
 closest obstacle right in front of it at 10 mm, the value of the IR-sensor2
 might be 400 instead at the same distance.
 This formula will try to make up for that difference so that each IR-sensor
 will will output the correct value at the same distance.
 Making it slightly more sensitive and accurate to respond to its surroundings.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename pictures/formuladistancemm.png
	lyxscale 70
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Formula for distance calculation
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "DistanceGraphFigure"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Conclusions / Tests
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "UpdateMapFigures"

\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align left
\begin_inset Graphics
	filename epuck_trajectory_pics/ObsUpdating1Brick.png
	lyxscale 30
	scale 15
	scaleBeforeRotation

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Moving to goal
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align right
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align right
\begin_inset Graphics
	filename logs/replanobstaclep1.png
	scale 60
	rotateOrigin centerTop

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align right
\begin_inset Caption Standard

\begin_layout Plain Layout
Map updated with obstacle
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align left
\begin_inset Graphics
	filename epuck_trajectory_pics/ObsUpdateing1BrickWayBack.png
	lyxscale 30
	scale 15
	scaleBeforeRotation

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Moving back to start point
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align right
\begin_inset Graphics
	filename logs/replanobstaclep2.png
	scale 60

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Re-plan with updated map
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Updating map with an obstacle (
\begin_inset CommandInset href
LatexCommand href
name "video"
target "https://drive.google.com/open?id=0B1G7rZ1HC6TpdGdTZWRTZGFuTlU"

\end_inset

)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Code to be found in appendix: 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperlink{DetectObstacle}{Detect Obstacle}
\end_layout

\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperlink{PlanReplan}{Plan and Replan}
\end_layout

\end_inset


\end_layout

\begin_layout Part
Implementation of Custom Made Fuzzy Rules
\end_layout

\begin_layout Section
Task
\end_layout

\begin_layout Standard
Implementing new custom made fuzzy rules can improve the behaviour of the
 ePuck and make it more cautious to nearby obstacles.
 There are a lot of things to keep in mind when developing more rules.
\end_layout

\begin_layout Standard
Problems that was encountered and had to be solved:
\end_layout

\begin_layout Itemize
Find and implement rules for certain situations where the ePuck would get
 stuck.
\end_layout

\begin_layout Itemize
Make up new rules by modifying/combining already existing ones?
\end_layout

\begin_layout Itemize
Make up new rules by writing from the scratch?
\end_layout

\begin_layout Itemize
Different threshold values than before?
\end_layout

\begin_layout Itemize
Making sure to not make contradicting rules
\end_layout

\begin_layout Standard
The custom made fuzzy rules was implemented with the monolithic approach.
 The fuzzy rules that was given as an example in the lecture slides was
 implemented at first.
 After testing scenarios with different setups of obstacles on the map,
 new rules were formed and the old were modified.
\end_layout

\begin_layout Section
Conclusions / Tests
\end_layout

\begin_layout Standard
When implementing the rules we thought about which situation a rule would
 apply to.
 It was very difficult to see when and where a rule would do as we expected
 and to make sure it wouldn't conflict with the other rules.
 A lot of time was spent to try and find the best rules by testing the ePuck
 extensively with different obstacle setups.
 Some setups may perhaps have been a bit extreme since we like it to be
 as precise as possible when moving around.
 This might've been a bit overkill.
 
\end_layout

\begin_layout Standard
As seen from the figures below, there are situations the custom made rules
 will be able to handle, but also some it won't, depending on where the
 goal is relative to its position and possible obstacles in-between.
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "CustomRulesFigures"

\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename epuck_trajectory_pics/OwnFuzzyAvoidMap1.png
	lyxscale 30
	scale 14
	scaleBeforeRotation

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Moves to goal successfully (
\begin_inset CommandInset href
LatexCommand href
name "video"
target "https://drive.google.com/open?id=0B1G7rZ1HC6TpNGNKMFhOejdXbVU"

\end_inset

)
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename epuck_trajectory_pics/OwnFuzzyAvoidMap3.png
	lyxscale 30
	scale 14
	scaleBeforeRotation

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Fails at moving out of the obstacle setup (
\begin_inset CommandInset href
LatexCommand href
name "video"
target "https://drive.google.com/open?id=0B1G7rZ1HC6Tpb2NwZDAwOVcwcVE"

\end_inset

)
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Custom Fuzzy Avoid Rules
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "CustomRulesFigures"

\end_inset

 one can see that in the first map the ePuck successfully managed to get
 to its target by avoiding the obstacles.
 However in the second map the ePuck could not find an opening that enabled
 it to get through without failing the rules.
 Since the goal was on the other side of the obstacle-wall, it couldn't
 go too far without following the rules, which told it to face the goal
 position as much as it could, while still avoiding the nearby obstacles
 causing it to go up and down between the top cells.
 Had there been an opening in the corner from where it started, it would
 have been able to get to the goal point without any problems.
 The provided video-links will give a better visualization of how the ePuck
 behaves in each situation.
 
\end_layout

\begin_layout Standard
Code in appendix: 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperlink{CustomFuzzyRules}{Custom Fuzzy Rules}
\end_layout

\end_inset


\end_layout

\begin_layout Part
Breadth-First Search vs.
 A*
\end_layout

\begin_layout Section
Task 
\end_layout

\begin_layout Standard
Breadth-first search and A* are two well-known path-finding algorithms that
 always finds the best solution.
 In general, Breadth-First Search (BFS) takes more time than A*.
 The higher number of nodes that exists in the map, the bigger time difference
 between the algorithms.
 This has to be taken into account to be able to state the advantages and
 the drawbacks of the algorithms.
\end_layout

\begin_layout Standard
A* generates a path that goes in a zig-zag pattern while Breadth-First search
 generates a path with a minimum number of turns.
 In the enforcement with the ePuck, the Breadth-First search could be better.
 This is because every time the ePuck rotates, some precision in the positioning
 is lost causing it to be misplaced in the environment even though it still
 thinks its on the correct path.
\end_layout

\begin_layout Section
Conclusions / Tests
\end_layout

\begin_layout Standard
In these tests we're using our own fuzzy rules and the implemented obstacle
 detection procedure.
\end_layout

\begin_layout Subsection
Path comparison
\end_layout

\begin_layout Subsubsection
Map 1
\end_layout

\begin_layout Standard
Here the path of the ePuck is compared between the algorithms, to see which
 of them takes a better path and how long it takes to get to the goal.
 The measured time to get to the goal should not be considered as an exact
 number, since there are many factors involved in how the ePuck will behave
 in different lighting.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename epuck_trajectory_pics/BFSDetectObsMap1.png
	lyxscale 30
	scale 14
	scaleBeforeRotation

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
BFS (
\begin_inset CommandInset href
LatexCommand href
name "video"
target "https://drive.google.com/open?id=0B1G7rZ1HC6TpTVMtdEV6QlNUTzQ"

\end_inset

)
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename epuck_trajectory_pics/AstarDetectObsMap1.png
	lyxscale 30
	scale 14
	scaleBeforeRotation

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
A* (
\begin_inset CommandInset href
LatexCommand href
name "video"
target "https://drive.google.com/open?id=0B1G7rZ1HC6TpTUE4bGxuTERJeGM"

\end_inset

)
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Map 1
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "BFSA*Map1"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "BFSA*Map1"

\end_inset

 both paths that are generated from the algorithms are similar, however
 the position of the ePuck is a bit off with the A*.
 The path with BFS took 16 seconds and with A* took 15 seconds which makes
 them very similar in this case.
 In the figure below the obstacle detection is shows for each algorithm.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align left
\begin_inset Graphics
	filename logs/searchobstaclemap1.png
	lyxscale 30
	scale 60
	scaleBeforeRotation

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
BFS
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align right
\begin_inset Graphics
	filename logs/Astarobstaclemap1.png
	lyxscale 30
	scale 60
	scaleBeforeRotation

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
A*
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Obstacle detection map 1
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Map 2
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename epuck_trajectory_pics/BFSDetectObsMap2.png
	lyxscale 30
	scale 14
	scaleBeforeRotation

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
BFS (
\begin_inset CommandInset href
LatexCommand href
name "video"
target "https://drive.google.com/open?id=0B1G7rZ1HC6TpVW4xb3hVYUEzYlE"

\end_inset

)
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename epuck_trajectory_pics/AstarDetectObsMap2.png
	lyxscale 30
	scale 14
	scaleBeforeRotation

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
A* (
\begin_inset CommandInset href
LatexCommand href
name "video"
target "https://drive.google.com/open?id=0B1G7rZ1HC6TpWWgyRFUzSExLN2s"

\end_inset

)
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Map 2
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "BFSA*Map2"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "BFSA*Map2"

\end_inset

 the generated paths are still similar but they still have some differences
 in their planning.
 When the path was generated with A* the ePuck deviated from the environment
 a bit, which was likely caused by some over-rotation when turning around
 a lot.
 It took 20 seconds for both paths for the ePuck to go from start to goal.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align left
\begin_inset Graphics
	filename logs/searchobstaclemap2.png
	lyxscale 30
	scale 60
	scaleBeforeRotation

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
BFS
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align right
\begin_inset Graphics
	filename logs/astarobstaclemap2.png
	lyxscale 30
	scale 60
	scaleBeforeRotation

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
A*
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Obstacle detection map 2
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Map 3
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename epuck_trajectory_pics/BFSDetectObsMap3.png
	lyxscale 30
	scale 14
	scaleBeforeRotation

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
BFS (
\begin_inset CommandInset href
LatexCommand href
name "video"
target "https://drive.google.com/open?id=0B1G7rZ1HC6TpY0t1d2c2anpzRzQ"

\end_inset

)
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename epuck_trajectory_pics/AstarDetectObsMap3.png
	lyxscale 30
	scale 14
	scaleBeforeRotation

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
A* (
\begin_inset CommandInset href
LatexCommand href
name "video"
target "https://drive.google.com/open?id=0B1G7rZ1HC6TpUnY4ZUtydzkxcWs"

\end_inset

)
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Map 3
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "BFSA*Map3"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "BFSA*Map3"

\end_inset

 shows us yet again the similarity between the algorithms.
 This time however, the path generated from BFS was about 1 second faster
 than A* (18 seconds vs 19 seconds).
 Again there are a lot of factors which may cause this.
 One is that the ePuck didn't rotate as much on one path, maybe it also
 didn't get as close to the wall as the other one did, which made it slow
 down.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align left
\begin_inset Graphics
	filename logs/searchobstaclemap3.png
	lyxscale 30
	scale 60
	scaleBeforeRotation

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
BFS
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align right
\begin_inset Graphics
	filename logs/astarobstaclemap3.png
	lyxscale 30
	scale 60
	scaleBeforeRotation

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
A*
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Obstacle detection map 3
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "BFSA*ObstacleFigure"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
As seen in the obstacle detection for A* in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "BFSA*ObstacleFigure"

\end_inset

 there are times when an obstacle is added when there's no obstacle there.
 This is likely caused by the inaccuracy of the sensors and how the ePuck
 rotated when it was following the path.
 This will be further discussed in the discussion section.
\end_layout

\begin_layout Standard
In theory both of the paths generated by respective algorithm should've
 taken the exact same time to execute, with this map size of course.
 In the next section the time measurements will be presented on how long
 it takes to find a path for each algorithm.
\end_layout

\begin_layout Subsection
Time Comparison
\end_layout

\begin_layout Standard
Comparing the run time of the algorithms was done in five simple tests.
 Only the actual run time of the algorithms themselves was measured with
 the C library function clock().
 No printing to the console or similar was included to eliminate as much
 time interference as possible.
 The different maps are filled with empty cells.
\end_layout

\begin_layout Standard
The start position is always at the upper left corner and the goal position
 is always at the lower right corner for all tests.
\end_layout

\begin_layout Subsubsection
Test 1
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="6">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Map size
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cells
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Start
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Goal
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A* (ms)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
BFS (ms)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8x8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $6\text{²}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(2, 2)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(7, 7)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.072
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.076
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection
Test 2 
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="6">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Map size
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cells
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Start
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Goal
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A* (ms)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
BFS (ms)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
50x50
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $48\text{²}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(2, 2)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(49, 49)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.452
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1.127
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection
Test 3 
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="6">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Map size
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cells
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Start
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Goal
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A* (ms)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
BFS (ms)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100x100
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $98\text{²}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(2, 2)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(99, 99)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1.053
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3.891
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection
Test 4 
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="6">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Map size
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cells
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Start
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Goal
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A* (ms)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
BFS (ms)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1000x1000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $998\text{²}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(2, 2)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(999, 999)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12.197
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
181.990
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection
Test 5 
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="6">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Map size
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cells
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Start
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Goal
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A* (ms)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
BFS (ms)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10000x10000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $9998\text{²}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(2, 2)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(9999, 9999)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
125.602
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16037.370
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

As one can see, A* wins in terms of how long it takes to find a path.
 However that's not to say that Breadth-First search is bad.
 Both of these algorithms performs very well on small maps but A* is the
 clear winner if there are bigger maps with more cells to search.
\begin_inset Newline newline
\end_inset

Code to be found in appendix: 
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperlink{A*}{A*}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperlink{BFS}{Breadth-First Search}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperlink{TimeMeasure}{Time Measurement}
\end_layout

\end_inset


\end_layout

\begin_layout Part
Distance Map Generation & Gradient Following
\end_layout

\begin_layout Section
Task 
\end_layout

\begin_layout Standard
The purpose of using a gradient following controller is to make the ePuck
 reach a specified destination without planning any sort of path.
 Instead it will look into each adjacent cell and go to the one with the
 least distance to the destination, similar to how Greedy Search works.
 This makes the system closer to a reactive architecture since there are
 no planning occurring and no detection of obstacles.
 However, it won't be guaranteed to take the shortest path.
\end_layout

\begin_layout Standard
In this case there was an environment model provided which was used to place
 out obstacles that are in the environment.
 Doing so makes the distance generation for each cell in the grid be correctly
 calculated and also eliminates the uncertainty of the environment.
\end_layout

\begin_layout Standard
The distance generation for the map was generated by using the Breadth-First
 Search algorithm, which expands in all cells around the destination, until
 it reaches the start position.
 The cells were labelled and assigned a heuristic value using the Euclidean
 formula from the position of the ePuck to the destination.
 The algorithm was activated for every new cell the ePuck entered, so that
 the heuristic values were updated.
\end_layout

\begin_layout Standard
Using the gradient following on the map, the ePuck was able to go to one
 of the adjacent cells with the least heuristic value, moving it closer
 to the goal, while avoiding obstacles.
\end_layout

\begin_layout Section
Conclusions / Tests
\end_layout

\begin_layout Standard
One problem that was encountered at first when using a set of difficult
 obstacles in the environment was that in some cells the heuristic values
 was the same.
 This caused the ePuck to move back and forth between two cells infinitely,
 since it would update the values when moving into each cell.
 It was solved by adding the value of the label of the cell together with
 the heuristic value.
 This solved the problem since the labels were smaller the closer it was
 to the goal.
 In figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "GradientMap1Figure"

\end_inset

 you may see a map on how the ePuck travelled in its own mind and compare
 it to a video which shows that it deviated a bit from the environmental
 position.
 This was most likely caused by the small motions caused when it was trying
 to pass the first obstacle.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename pictures/gradientmap1.png
	lyxscale 50
	scale 50

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Gradient following Map 1(
\begin_inset CommandInset href
LatexCommand href
name "video"
target "https://drive.google.com/open?id=0B1G7rZ1HC6TpWXNvNF9KS05GSUE"

\end_inset

)
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "GradientMap1Figure"

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the video it was seen that the ePuck touched the obstacle.
 One possible reason for this might be that the top-right sensor wasn't
 properly tuned and noticed the barrier too late, which caused it to rotate
 to left after it had hit it.
 Another reason is that it went too fast, thinking it had free passage and
 didn't stop or reduce the speed until the sensor on the right had a high
 value.
 Overall, it managed to complete some difficult maps without deviating too
 much from the environment seen in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "GradientMapsFigure"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename pictures/gradientmap2.png
	lyxscale 30
	scale 50
	scaleBeforeRotation

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Map 2
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename pictures/gradientmap3.png
	lyxscale 30
	scale 50
	scaleBeforeRotation

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Map 3
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Different Gradient following Maps
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "GradientMapsFigure"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Code to be found in appendix: 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperlink{Gradient}{Gradient Following}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Discussion
\end_layout

\begin_layout Subsubsection
Combining rules
\end_layout

\begin_layout Standard
For implementing the fuzzy rule-based control for obstacle avoidance, we
 first used the monolithic approach first because we didn't really have
 a preference.
 Without making our own fuzzy rules, the ePuck performed okay if we used
 a static obstacle map without unexpected obstacles.
 After some tuning on the thresholds and increasing the speed factors, we
 could see some improvements (Increased speed, quicker turns etc.).
 A higher speed also sometimes resulted in better position estimation.
 It seemed like the ePuck was misplaced while turning too slow for example.
\end_layout

\begin_layout Standard
The same fuzzy rules but with added unexpected obstacles made the ePuck
 perform very poor and get stuck even in what could be considered as the
 simplest situations.
 The figures in the tests of Part I can show this.
 Sometimes the fuzzy sets were empty which means that no value is given
 to, for example, the rotation fuzzy predicate set.
 To solve this, more rules are needed for handling these situations.
 We also made a few tests with the modular approach which at that point
 didnt make any difference, so instead we went back to monolithic and stayed
 there.
\end_layout

\begin_layout Subsubsection
Custom fuzzy rules
\end_layout

\begin_layout Standard
The implementation of our own fuzzy rules took a lot of time for us.
 We had trouble to get into the concept of fuzzy logic, so that caused us
 to be ineffective in creating good rules.
\end_layout

\begin_layout Standard
We tried different combinations depending on each imaginable situation of
 the ePuck's state, but ended up in situations where the rules were too
 long and hard to follow.
\end_layout

\begin_layout Standard
But in the end, we started from the beginning with no rules and started
 to construct them them from scenarios where it failed and continued that
 way until we had a ruleset that worked.
 The program still fails sometimes, but the pictures from the tests in Part
 III shows the results from how it most of the time works.
\end_layout

\begin_layout Subsubsection
Obstacle detection
\end_layout

\begin_layout Standard
We already had a plan about updating the map with obstacles was implemented.
 The IR-sensors was the most essential tool combined with good position
 estimation.
 With our implementation we had to decide in which cell a detected obstacle
 was located, depending on the location of the ePuck, so some calibration
 had to be done to each IR-sensor to compensate for the eventual noise.
 All in all, the updating of the map went good.
 Though sometimes the lack in precision made an obstacle appear in the wrong
 cell, often when the obstacle was on or near the edge between two cells.
 An example is when the ePuck moves near the edges (walls) of the map.
 Better calibration and a more precise MATLAB generated function could possibly
 help solving these problems.
\end_layout

\begin_layout Subsubsection
Gradient following
\end_layout

\begin_layout Standard
The implementation of gradient following was made quickly in the end without
 combining it with obstacle detection.
 This made it work fine on static maps were no unexpected obstacles existed.
 An advantage with gradient following is that no plan is needed, but therefore
 it is not able to guarantee that it is moving on the closest path.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Discuss the quality of your system, based on the above results, comment
 on the limitations and say how these could be overcome.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\start_of_appendix
\align center

\size larger
Appendix
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
FollowPath
\end_layout

\end_inset


\begin_inset Float table
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hypertarget{FollowPath}{Path following function}
\end_layout

\end_inset


\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

// Wrapper function for being able to use Track() again after a run is done.
\end_layout

\begin_layout Plain Layout

void FollowPath()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    InitMap = *CreateMapFromFile(SYM, MapFile_Save);
\end_layout

\begin_layout Plain Layout

    WorkMap = *CreateMapFromFile(SYM, MapFile_Save);
\end_layout

\begin_layout Plain Layout

    int run = 1;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    while (run)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        WorkMap.map[StartCell.i][StartCell.j] = MAP_START;
\end_layout

\begin_layout Plain Layout

        WorkMap.map[GoalCell.i][GoalCell.j] = MAP_GOAL;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        Plan(StartCell, GoalCell);
\end_layout

\begin_layout Plain Layout

        PrintMap(&WorkMap);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        int nRoutes = GenerateRoute();
\end_layout

\begin_layout Plain Layout

        TranslateCellsToCoords(nRoutes);
\end_layout

\begin_layout Plain Layout

        PrintWaypoints(nRoutes);
\end_layout

\begin_layout Plain Layout

        Track(WaypointsCoords, nRoutes);
\end_layout

\begin_layout Plain Layout

        if (ObsDetected)
\end_layout

\begin_layout Plain Layout

            Replan();
\end_layout

\begin_layout Plain Layout

        else
\end_layout

\begin_layout Plain Layout

            run = 0;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    printf("End of FollowPath
\backslash
n");
\end_layout

\begin_layout Plain Layout

    SaveMapToFile(&InitMap, SYM, MapFile_Save);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Track
\end_layout

\end_inset


\begin_inset Float table
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hypertarget{Track}{Track function}
\end_layout

\end_inset


\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

// Goes through a list of waypoints to instruct the ePuck where to go.
\end_layout

\begin_layout Plain Layout

void Track(Position positions[], int size)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    int i;
\end_layout

\begin_layout Plain Layout

    for (i = 0; i < size; ++i)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        printf("Track position coords: (%.2lf, %.2lf)
\backslash
n", positions[i].x, positions[i].y);
\end_layout

\begin_layout Plain Layout

        GoToAvoid_fuzzy(positions[i].x, positions[i].y);
\end_layout

\begin_layout Plain Layout

        if (ObsDetected)
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

            // Abort the track to replan
\end_layout

\begin_layout Plain Layout

            return;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
DetectObstacle
\end_layout

\end_inset


\begin_inset Float table
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hypertarget{DetectObstacle}{Obstacle Detection function}
\end_layout

\end_inset


\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

// Scans for nearby obstacles.
\end_layout

\begin_layout Plain Layout

int DetectObstacle()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    IR = GetIR();
\end_layout

\begin_layout Plain Layout

    int obsAheadVal = 500;
\end_layout

\begin_layout Plain Layout

    int obsLeftVal = 700;
\end_layout

\begin_layout Plain Layout

    int obsRightVal = 700;
\end_layout

\begin_layout Plain Layout

    double distOffset = 15.0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    if (IR.sensor[0] > obsAheadVal || IR.sensor[7] > obsAheadVal)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        double distAvg = ObsDistance(max(IR.sensor[0], IR.sensor[7]), DIST_F_AHEAD
);
\end_layout

\begin_layout Plain Layout

        SetObstacle(0.0, distAvg + distOffset);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    if (IR.sensor[2] > obsRightVal)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        double distance = (ObsDistance(IR.sensor[2], DIST_F_RIGHT));
\end_layout

\begin_layout Plain Layout

        SetObstacle(-PI / 2, distance + distOffset);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    if (IR.sensor[5] > obsLeftVal)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        double distance = (ObsDistance(IR.sensor[5], DIST_F_LEFT));
\end_layout

\begin_layout Plain Layout

        SetObstacle(PI / 2, distance + distOffset);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    return ObsDetected;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
SetObstacle
\end_layout

\end_inset


\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
Setting Obstacle function
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

// MATLAB generated function which calculates distance from the ePuck to
 an obstacle.
\end_layout

\begin_layout Plain Layout

double ObsDistance(int IRvalue, float F)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    return (8.7 * pow(10, -7) * pow(IRvalue, 2) - 0.0087 * IRvalue + 23) *
 F;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Update a cell with a detected object.
\end_layout

\begin_layout Plain Layout

void SetObstacle(float offsetAngle, float distance)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    // Check in which cell the IR sensor detected something.
\end_layout

\begin_layout Plain Layout

    Cell c = TranslateCoordToCell(cos(RobPos.th + offsetAngle) * (distance
 + ROBOT_RAD) + RobPos.x,
\end_layout

\begin_layout Plain Layout

                                  sin(RobPos.th + offsetAngle) * (distance
 + ROBOT_RAD) + RobPos.y);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    int cVal = WorkMap.map[c.i][c.j];
\end_layout

\begin_layout Plain Layout

    if (cVal != MAP_OBSTACLE && cVal != MAP_BORDER)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        // printf("Obstacle not in map!
\backslash
n");
\end_layout

\begin_layout Plain Layout

        InitMap.map[c.i][c.j] = MAP_OBSTACLE;
\end_layout

\begin_layout Plain Layout

        if (cVal == MAP_TRACE)
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

            ObsDetected = 1;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Plan
\end_layout

\end_inset


\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hypertarget{PlanReplan}{Plan and Replan functions}
\end_layout

\end_inset


\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

// Plans the shortest waypoint path between start and goal.
\end_layout

\begin_layout Plain Layout

void Plan(Cell start, Cell goal)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    // Comment out the algorithm below which will not be used.
\end_layout

\begin_layout Plain Layout

    Search(start, goal);
\end_layout

\begin_layout Plain Layout

    // AStarSearch(start, goal);    
\end_layout

\begin_layout Plain Layout

    Cell curr = start;
\end_layout

\begin_layout Plain Layout

    Cell next;
\end_layout

\begin_layout Plain Layout

    nWaypoints = 0;
\end_layout

\begin_layout Plain Layout

    printf("C:(%d, %d) (Start)
\backslash
n", curr.i, curr.j);
\end_layout

\begin_layout Plain Layout

    do
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        next = GetNextNeighbour(curr);
\end_layout

\begin_layout Plain Layout

        if (nWaypoints)
\end_layout

\begin_layout Plain Layout

            WorkMap.map[curr.i][curr.j] = MAP_TRACE;
\end_layout

\begin_layout Plain Layout

        PathCells[nWaypoints] = next;
\end_layout

\begin_layout Plain Layout

        nWaypoints++;
\end_layout

\begin_layout Plain Layout

        printf("C:(%d, %d) (MVal: %d)
\backslash
n", next.i, next.j, WorkMap.map[next.i][next.j]);
\end_layout

\begin_layout Plain Layout

        if (curr.i == next.i && curr.j == next.j)
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

            printf("PATH NOT FOUND
\backslash
n");
\end_layout

\begin_layout Plain Layout

            exit(0);
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        curr = next;
\end_layout

\begin_layout Plain Layout

    } while (WorkMap.map[curr.i][curr.j] != MAP_GOAL);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Replan
\end_layout

\end_inset


\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
Replan
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

// New obstacle aborted current run.
 Plan a new route.
\end_layout

\begin_layout Plain Layout

void Replan()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    printf("Added obstacle to cell ahead.
 Replanning!
\backslash
n");
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Updating Map with new obstacles
\end_layout

\begin_layout Plain Layout

    SaveMapToFile(&InitMap, SYM, MapFile_Save);
\end_layout

\begin_layout Plain Layout

    WorkMap = *CreateMapFromFile(SYM, MapFile_Save);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    ObsDetected = 0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Sets the new position to start from
\end_layout

\begin_layout Plain Layout

    Cell RobCell = TranslateCoordToCell(RobPos.x, RobPos.y);
\end_layout

\begin_layout Plain Layout

    if (WorkMap.map[RobCell.i][RobCell.j] == MAP_OBSTACLE)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        // Obstacle detected in same cell as ePuck.
 Return to last visited path cell.
\end_layout

\begin_layout Plain Layout

        ReturningtoPrev = 1;
\end_layout

\begin_layout Plain Layout

        prevpos = TranslateCelltoCoords(PrevCell);
\end_layout

\begin_layout Plain Layout

        printf("Going back to prev cell
\backslash
n");
\end_layout

\begin_layout Plain Layout

        GoToAvoid_fuzzy(prevpos.x, prevpos.y);
\end_layout

\begin_layout Plain Layout

        ReturningtoPrev = 0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        if (WorkMap.map[PrevCell.i][PrevCell.j] != MAP_OBSTACLE)
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

            StartCell.i = PrevCell.i;
\end_layout

\begin_layout Plain Layout

            StartCell.j = PrevCell.j;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    else
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        StartCell.i = RobCell.i;
\end_layout

\begin_layout Plain Layout

        StartCell.j = RobCell.j;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Resets used lists
\end_layout

\begin_layout Plain Layout

    memset(PathCells, 0, sizeof(PathCells));
\end_layout

\begin_layout Plain Layout

    memset(WaypointCells, 0, sizeof(WaypointCells));
\end_layout

\begin_layout Plain Layout

    memset(WaypointsCoords, 0, sizeof(WaypointsCoords));
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
GetNextNeighbour
\end_layout

\end_inset


\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
GetNextCellNeighbour
\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

// Checks the four neigbours of a cell to plan a path.
\end_layout

\begin_layout Plain Layout

Cell GetNextNeighbour(Cell c)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    int next_nr = 99999;
\end_layout

\begin_layout Plain Layout

    Cell next_c;
\end_layout

\begin_layout Plain Layout

    if (WorkMap.map[c.i - 1][c.j] < next_nr && WorkMap.map[c.i - 1][c.j] >= 0)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        next_nr = WorkMap.map[c.i - 1][c.j];
\end_layout

\begin_layout Plain Layout

        next_c.i = c.i - 1;
\end_layout

\begin_layout Plain Layout

        next_c.j = c.j;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    if (WorkMap.map[c.i + 1][c.j] < next_nr && WorkMap.map[c.i + 1][c.j] >= 0)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        next_nr = WorkMap.map[c.i + 1][c.j];
\end_layout

\begin_layout Plain Layout

        next_c.i = c.i + 1;
\end_layout

\begin_layout Plain Layout

        next_c.j = c.j;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    if (WorkMap.map[c.i][c.j - 1] < next_nr && WorkMap.map[c.i][c.j - 1] >= 0)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        next_nr = WorkMap.map[c.i][c.j - 1];
\end_layout

\begin_layout Plain Layout

        next_c.i = c.i;
\end_layout

\begin_layout Plain Layout

        next_c.j = c.j - 1;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    if (WorkMap.map[c.i][c.j + 1] < next_nr && WorkMap.map[c.i][c.j + 1] >= 0)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        next_nr = WorkMap.map[c.i][c.j + 1];
\end_layout

\begin_layout Plain Layout

        next_c.i = c.i;
\end_layout

\begin_layout Plain Layout

        next_c.j = c.j + 1;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    return next_c;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
GenerateRoute
\end_layout

\end_inset


\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
Generate a route with waypoints from the pathplanning without unnecessary
 waypoints
\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

// Generates the final waypoints by removing all redundant waypoints in
 the path.
\end_layout

\begin_layout Plain Layout

int GenerateRoute()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    int i_change = 0, j_change = 0, route_index = 0;
\end_layout

\begin_layout Plain Layout

    WaypointCells[route_index++] = PathCells[0];
\end_layout

\begin_layout Plain Layout

    for (int i = 1; i < nWaypoints; ++i)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        if (!i_change)
\end_layout

\begin_layout Plain Layout

            if (PathCells[i].i - PathCells[i - 1].i != 0)
\end_layout

\begin_layout Plain Layout

            {
\end_layout

\begin_layout Plain Layout

                i_change++;
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

        if (!j_change)
\end_layout

\begin_layout Plain Layout

            if (PathCells[i].j - PathCells[i - 1].j != 0)
\end_layout

\begin_layout Plain Layout

            {
\end_layout

\begin_layout Plain Layout

                j_change++;
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

        if (abs(i_change) && abs(j_change)) // Did both i and j values change?
 (Did the ePuck turn?)
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

            WaypointCells[route_index++] = PathCells[i-- - 1]; // If the
 ePuck turned, add waypoint.
\end_layout

\begin_layout Plain Layout

            i_change = 0;
\end_layout

\begin_layout Plain Layout

            j_change = 0;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    WaypointCells[route_index++] = PathCells[nWaypoints - 1]; // The goal
 has to be the last waypoint.
\end_layout

\begin_layout Plain Layout

    return route_index;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
GoToAvoid
\end_layout

\end_inset


\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hypertarget{CustomFuzzyRules}{GoToAvoid and Fuzzy Rules}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

void GoToAvoid_fuzzy(double xt, double yt)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    double vlin, vrot;
\end_layout

\begin_layout Plain Layout

    do
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        // New detected obstacle in the current planned path? Abort and
 replan.
\end_layout

\begin_layout Plain Layout

        if (DetectObstacle() && !ReturningtoPrev)
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

            Stop();
\end_layout

\begin_layout Plain Layout

            return;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        UpdatePosition();
\end_layout

\begin_layout Plain Layout

        ClearFSet(f_set_vlin);
\end_layout

\begin_layout Plain Layout

        ClearFSet(f_set_vrot);
\end_layout

\begin_layout Plain Layout

        GotoAvoidRules(xt, yt);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        DeFuzzify(f_set_vrot, 3, &f_vrot);
\end_layout

\begin_layout Plain Layout

        DeFuzzify(f_set_vlin, 4, &f_vlin);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        vlin = ResponseToVel(f_vlin);
\end_layout

\begin_layout Plain Layout

        vrot = ResponseToRot(f_vrot);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        SetPolarSpeed(vlin, vrot);
\end_layout

\begin_layout Plain Layout

        Sleep(10);
\end_layout

\begin_layout Plain Layout

    } while (Epos > 30);
\end_layout

\begin_layout Plain Layout

    Stop();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
FuzzyRules
\end_layout

\end_inset


\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

void GotoAvoidRules(double xt, double yt)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    // GoTo -----------------------------------------------------------
\end_layout

\begin_layout Plain Layout

    double dx, dy;
\end_layout

\begin_layout Plain Layout

    FPred Pos_Left, Pos_Right, Pos_Ahead, Pos_Here;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Compute Eth and Epos
\end_layout

\begin_layout Plain Layout

    dx = xt - RobPos.x;
\end_layout

\begin_layout Plain Layout

    dy = yt - RobPos.y;
\end_layout

\begin_layout Plain Layout

    Epos = sqrt(pow(dx, 2) + pow(dy, 2));
\end_layout

\begin_layout Plain Layout

    Eth = NormAng(atan2(dy, dx) - RobPos.th);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    Pos_Left = RampUp(Eth, 0, PI / 3.0);
\end_layout

\begin_layout Plain Layout

    Pos_Right = RampDown(Eth, PI / -3.0, 0);
\end_layout

\begin_layout Plain Layout

    Pos_Ahead = min(RampUp(Eth, PI / -7.0, 0), RampDown(Eth, 0, PI / 7.0));
\end_layout

\begin_layout Plain Layout

    Pos_Here = RampDown(Epos, 5, 50);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Avoid -----------------------------------------------------------
\end_layout

\begin_layout Plain Layout

    FPred Obs_Left, Obs_Right, Obs_Ahead, Obs_Back;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    IR = GetIR();
\end_layout

\begin_layout Plain Layout

    Obs_Left = RampUp(max(IR.sensor[5], IR.sensor[6]), 300, 1000);
\end_layout

\begin_layout Plain Layout

    Obs_Right = RampUp(max(IR.sensor[1], IR.sensor[2]), 300, 1000);
\end_layout

\begin_layout Plain Layout

    Obs_Ahead = RampUp(max(IR.sensor[0], IR.sensor[7]), 200, 800);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    RULESET;
\end_layout

\begin_layout Plain Layout

    // Rotation rules
\end_layout

\begin_layout Plain Layout

    IF(AND(Pos_Left, NOT(Obs_Left)));    ROT(LEFT);
\end_layout

\begin_layout Plain Layout

    IF(AND(AND(Obs_Right, NOT(Obs_Left)), NOT(Pos_Ahead)));    ROT(LEFT);
\end_layout

\begin_layout Plain Layout

    IF(AND(Pos_Ahead, Obs_Right));    ROT(LEFT);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    IF(AND(Pos_Right, NOT(Obs_Right)));    ROT(RIGHT);
\end_layout

\begin_layout Plain Layout

    IF(AND(AND(Obs_Left, NOT(Obs_Right)), NOT(Pos_Ahead)));    ROT(RIGHT);
\end_layout

\begin_layout Plain Layout

    IF(AND(Pos_Ahead, Obs_Left));    ROT(RIGHT);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    IF(AND(Pos_Ahead, NOT(Obs_Ahead)));    ROT(AHEAD);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Velocity rules
\end_layout

\begin_layout Plain Layout

    IF(AND(AND(AND(Pos_Ahead, NOT(Pos_Here)), AND(NOT(Obs_Left), NOT(Obs_Right))
), NOT(Obs_Ahead)));    VEL(FAST);
\end_layout

\begin_layout Plain Layout

    IF(OR(Pos_Here, NOT(Pos_Ahead)));     VEL(NONE);
\end_layout

\begin_layout Plain Layout

    IF(Obs_Ahead);					    VEL(NONE);
\end_layout

\begin_layout Plain Layout

    IF(AND(OR(Obs_Right, Obs_Left), NOT(Obs_Ahead)));    VEL(SLOW);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    RULEEND;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Pathfinding algorithms
\end_layout

\end_inset


\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hypertarget{BFS}{Breadth-First Search}
\end_layout

\end_inset


\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

// Breadth-First Search
\end_layout

\begin_layout Plain Layout

void Search(Cell start, Cell goal)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    ClearList(&SearchList, FIFO);
\end_layout

\begin_layout Plain Layout

    Push(&SearchList, goal);
\end_layout

\begin_layout Plain Layout

    while (!IsListEmpty(&SearchList))
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        Cell current = Pop(&SearchList);
\end_layout

\begin_layout Plain Layout

        if (current.i == start.i && current.j == start.j)
\end_layout

\begin_layout Plain Layout

            break;
\end_layout

\begin_layout Plain Layout

        int dist = WorkMap.map[current.i][current.j] + 1;
\end_layout

\begin_layout Plain Layout

        MarkCell(current.i, current.j - 1, dist);
\end_layout

\begin_layout Plain Layout

        MarkCell(current.i, current.j + 1, dist);
\end_layout

\begin_layout Plain Layout

        MarkCell(current.i - 1, current.j, dist);
\end_layout

\begin_layout Plain Layout

        MarkCell(current.i + 1, current.j, dist);
\end_layout

\begin_layout Plain Layout

        PrintMap(&WorkMap);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hypertarget{A*}{A*}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

void AStarSearch(Cell start, Cell goal)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    ClearList(&SearchList, SORTED);
\end_layout

\begin_layout Plain Layout

    Push(&SearchList, goal);
\end_layout

\begin_layout Plain Layout

    while (!IsListEmpty(&SearchList))
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        Cell current = Pop(&SearchList);
\end_layout

\begin_layout Plain Layout

        if (current.i == start.i && current.j == start.j)
\end_layout

\begin_layout Plain Layout

            break;
\end_layout

\begin_layout Plain Layout

        int dist = WorkMap.map[current.i][current.j] + 1;
\end_layout

\begin_layout Plain Layout

        MarkCell(current.i, current.j - 1, dist);
\end_layout

\begin_layout Plain Layout

        MarkCell(current.i, current.j + 1, dist);
\end_layout

\begin_layout Plain Layout

        MarkCell(current.i - 1, current.j, dist);
\end_layout

\begin_layout Plain Layout

        MarkCell(current.i + 1, current.j, dist);
\end_layout

\begin_layout Plain Layout

        PrintMap(&WorkMap);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
TimeMeasure Astar and BFS
\end_layout

\end_inset


\begin_inset Float table
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hypertarget{TimeMeasure}{Time measurement function for BFS and A*}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

// Small time measuring program for comparing A* with BFS.
\end_layout

\begin_layout Plain Layout

void TimeMeasureAstarBFS()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    int size;
\end_layout

\begin_layout Plain Layout

    int algChoice;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    printf("Choose algorithm:
\backslash
n1.
 A*
\backslash
n2.
 BFS
\backslash
n");
\end_layout

\begin_layout Plain Layout

    scanf("%d", &algChoice);
\end_layout

\begin_layout Plain Layout

    printf("Enter map side size:
\backslash
n");
\end_layout

\begin_layout Plain Layout

    scanf("%d", &size);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    StartCell = {1, 1, 0.0};
\end_layout

\begin_layout Plain Layout

    GoalCell = {size - 2, size - 2, 0.0};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    WorkMap = *CreateBorderedMap(size, size, DEFAULT_MAX_VALUE);
\end_layout

\begin_layout Plain Layout

    WorkMap.map[StartCell.i][StartCell.j] = MAP_START;
\end_layout

\begin_layout Plain Layout

    WorkMap.map[GoalCell.i][GoalCell.j] = MAP_GOAL;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    clock_t start;
\end_layout

\begin_layout Plain Layout

    switch (algChoice)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

    case 1:
\end_layout

\begin_layout Plain Layout

        printf("Running A* on map side size %d...
\backslash
n", size);
\end_layout

\begin_layout Plain Layout

        start = clock();
\end_layout

\begin_layout Plain Layout

        AStarSearch(StartCell, GoalCell);
\end_layout

\begin_layout Plain Layout

        break;
\end_layout

\begin_layout Plain Layout

    case 2:
\end_layout

\begin_layout Plain Layout

        printf("Running BFS on map side size %d...
\backslash
n", size);
\end_layout

\begin_layout Plain Layout

        start = clock();
\end_layout

\begin_layout Plain Layout

        Search(StartCell, GoalCell);
\end_layout

\begin_layout Plain Layout

        break;
\end_layout

\begin_layout Plain Layout

    default:
\end_layout

\begin_layout Plain Layout

        break;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    clock_t end = clock();
\end_layout

\begin_layout Plain Layout

    float ms = (float)(end - start) / CLOCKS_PER_SEC * 1000;
\end_layout

\begin_layout Plain Layout

    printf("Measured milliseconds: %lf
\backslash
n", ms);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
MarkCell
\end_layout

\end_inset


\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
MarkCell function for BFS and Astar functions
\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

// Labels cells with information while searching.
\end_layout

\begin_layout Plain Layout

void MarkCell(int i, int j, int label)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    Cell c = {i, j, 0.0};
\end_layout

\begin_layout Plain Layout

    int di, dj;
\end_layout

\begin_layout Plain Layout

    switch (WorkMap.map[i][j])
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

    case -1: // Initial position
\end_layout

\begin_layout Plain Layout

        Push(&SearchList, c);
\end_layout

\begin_layout Plain Layout

        break;
\end_layout

\begin_layout Plain Layout

    case -2: // Unexplored c
\end_layout

\begin_layout Plain Layout

    case -6:
\end_layout

\begin_layout Plain Layout

        WorkMap.map[i][j] = label;
\end_layout

\begin_layout Plain Layout

        c.h_value = heuristic(i, j, StartCell);
\end_layout

\begin_layout Plain Layout

        HValueList[i][j] = heuristic(i, j, GoalCell);
\end_layout

\begin_layout Plain Layout

        Push(&SearchList, c);
\end_layout

\begin_layout Plain Layout

        break;
\end_layout

\begin_layout Plain Layout

    case -3: // Obstacle
\end_layout

\begin_layout Plain Layout

        c.h_value = 0.0;
\end_layout

\begin_layout Plain Layout

        break;
\end_layout

\begin_layout Plain Layout

    case -4: // Out of boundaries
\end_layout

\begin_layout Plain Layout

        break;
\end_layout

\begin_layout Plain Layout

    default: // Already explored
\end_layout

\begin_layout Plain Layout

        break;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Gradient
\end_layout

\end_inset


\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hypertarget{Gradient}{Get the best cell for FollowGradient function}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

// Evaluates the four neighbours of a cell while gradient following.
 Returns the current best choice.
\end_layout

\begin_layout Plain Layout

Cell GetBestGradient(Cell robc)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    double next_nr = 99999.99;
\end_layout

\begin_layout Plain Layout

    Cell next_c;
\end_layout

\begin_layout Plain Layout

    Cell neighbours[4] = {{robc.i, robc.j - 1},
\end_layout

\begin_layout Plain Layout

                          {robc.i - 1, robc.j},
\end_layout

\begin_layout Plain Layout

                          {robc.i + 1, robc.j},
\end_layout

\begin_layout Plain Layout

                          {robc.i, robc.j + 1}};
\end_layout

\begin_layout Plain Layout

    for (int i = 0; i < 4; ++i)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        neighbours[i].h_value = HValueList[neighbours[i].i][neighbours[i].j];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        double cellVal = WorkMap.map[neighbours[i].i][neighbours[i].j];
\end_layout

\begin_layout Plain Layout

        double cellH = HValueList[neighbours[i].i][neighbours[i].j] + cellVal;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        if (cellH < next_nr && cellH > 0.0 &&
\end_layout

\begin_layout Plain Layout

            cellVal != MAP_BORDER &&
\end_layout

\begin_layout Plain Layout

            cellVal != MAP_OBSTACLE)
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

            next_c.i = neighbours[i].i;
\end_layout

\begin_layout Plain Layout

            next_c.j = neighbours[i].j;
\end_layout

\begin_layout Plain Layout

            next_c.h_value = next_nr = neighbours[i].h_value = cellH;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        else if (WorkMap.map[neighbours[i].i][neighbours[i].j] == MAP_GOAL)
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

            next_c = GoalCell;
\end_layout

\begin_layout Plain Layout

            break;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    return next_c;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
FollowGradient
\end_layout

\end_inset


\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
Gradient Following function
\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

// Function for making the ePuck follow the gradient.
\end_layout

\begin_layout Plain Layout

void FollowGradient()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    InitMap = *CreateMapFromFile(SYM, MapFile_Gradient);
\end_layout

\begin_layout Plain Layout

    WorkMap = *CreateMapFromFile(SYM, MapFile_Gradient);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    WorkMap.map[StartCell.i][StartCell.j] = MAP_START;
\end_layout

\begin_layout Plain Layout

    WorkMap.map[GoalCell.i][GoalCell.j] = MAP_GOAL;
\end_layout

\begin_layout Plain Layout

    do
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        Search(StartCell, GoalCell);
\end_layout

\begin_layout Plain Layout

        PrintMap(&WorkMap);
\end_layout

\begin_layout Plain Layout

        Cell newCell = GetBestGradient(CurrCell);
\end_layout

\begin_layout Plain Layout

        Position coords = TranslateCelltoCoords(newCell);
\end_layout

\begin_layout Plain Layout

        GoToAvoid_fuzzy(coords.x, coords.y);
\end_layout

\begin_layout Plain Layout

        StartCell = CurrCell;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    } while (!(CurrCell.i == GoalCell.i && CurrCell.j == GoalCell.j));
\end_layout

\begin_layout Plain Layout

    printf("End of FollowGradient
\backslash
n");
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Update Position
\end_layout

\end_inset


\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
Update Position
\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

// Calculates and updates the estimated position of the ePuck by approximation.
\end_layout

\begin_layout Plain Layout

void UpdatePosition()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    newSteps = GetSteps();
\end_layout

\begin_layout Plain Layout

    diffSteps.l = newSteps.l - prevSteps.l;
\end_layout

\begin_layout Plain Layout

    diffSteps.r = newSteps.r - prevSteps.r;
\end_layout

\begin_layout Plain Layout

    double diffmmL = (diffSteps.l) / STEPS_PER_MM;
\end_layout

\begin_layout Plain Layout

    double diffmmR = (diffSteps.r) / STEPS_PER_MM;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    double dist = (diffmmL + diffmmR) / 2;
\end_layout

\begin_layout Plain Layout

    double ang = (diffmmR - diffmmL) / CRD;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    double dx = dist * cos(ang / 2);
\end_layout

\begin_layout Plain Layout

    double dy = dist * sin(ang / 2);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    prevSteps = newSteps;
\end_layout

\begin_layout Plain Layout

    RobPos.x += dx * cos(thPrev) - dy * sin(thPrev);
\end_layout

\begin_layout Plain Layout

    RobPos.y += dx * sin(thPrev) + dy * cos(thPrev);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    double th = NormAng(ang + thPrev);
\end_layout

\begin_layout Plain Layout

    RobPos.th = th;
\end_layout

\begin_layout Plain Layout

    thPrev = th;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    CurrCell = TranslateCoordToCell(RobPos.x, RobPos.y);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // Keeps track of the last visited cell that was part of the calculated
 path.
\end_layout

\begin_layout Plain Layout

    for (int i = 1; i < nWaypoints; ++i)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        if (PathCells[i].i == CurrCell.i && PathCells[i].j == CurrCell.j)
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

            PrevCell.i = PathCells[i - 1].i;
\end_layout

\begin_layout Plain Layout

            PrevCell.j = PathCells[i - 1].j;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Translate functions
\end_layout

\end_inset


\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
Translation Functions from Coordinates to Cell vv.
\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

// Translates the position of each waypoint cell into real coordinates.
\end_layout

\begin_layout Plain Layout

void TranslateCellsToCoords(int nCoords)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    for (int i = 0; i < nCoords; ++i)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        Position coords = TranslateCelltoCoords(WaypointCells[i]);
\end_layout

\begin_layout Plain Layout

        WaypointsCoords[i].x = coords.x;
\end_layout

\begin_layout Plain Layout

        WaypointsCoords[i].y = coords.y;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Translate a map cell into coordinates.
\end_layout

\begin_layout Plain Layout

Position TranslateCelltoCoords(Cell c)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    double x = (c.j - RefCell.j) * mmCell;
\end_layout

\begin_layout Plain Layout

    double y = (RefCell.i - c.i) * mmCell;
\end_layout

\begin_layout Plain Layout

    Position coords = {x, y};
\end_layout

\begin_layout Plain Layout

    return coords;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Translate coordinates into a map cell.
\end_layout

\begin_layout Plain Layout

Cell TranslateCoordToCell(float x, float y)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    Cell result;
\end_layout

\begin_layout Plain Layout

    result.j = round(x / mmCell + RefCell.j);
\end_layout

\begin_layout Plain Layout

    result.i = round(RefCell.i - y / mmCell);
\end_layout

\begin_layout Plain Layout

    return result;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Other functions
\end_layout

\end_inset


\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
Small Functions
\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

int ResponseToVel(float response)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    // If the response is 0.33, the linear speed should be 0.
\end_layout

\begin_layout Plain Layout

    const double limit = 0.33;
\end_layout

\begin_layout Plain Layout

    return -(limit - response) * VMAX_;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

double ResponseToRot(float response)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    // If the response is 0.5, the rotation speed should be 0.
\end_layout

\begin_layout Plain Layout

    const double limit = 0.5;
\end_layout

\begin_layout Plain Layout

    double factor = (limit - response);
\end_layout

\begin_layout Plain Layout

    return factor * PI * ROTFACTOR;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Calculates heuristic value with the Pythagorean theorem.
\end_layout

\begin_layout Plain Layout

double heuristic(int i, int j, Cell c)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    int di = i - c.i;
\end_layout

\begin_layout Plain Layout

    int dj = c.j - j;
\end_layout

\begin_layout Plain Layout

    return sqrt(pow(di, 2) + pow(dj, 2));
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Translates an angle to a value between -PI and PI.
\end_layout

\begin_layout Plain Layout

double NormAng(double a)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    double norm_a = a;
\end_layout

\begin_layout Plain Layout

    if (a > PI)
\end_layout

\begin_layout Plain Layout

        norm_a -= 2 * PI;
\end_layout

\begin_layout Plain Layout

    else if (a < -PI)
\end_layout

\begin_layout Plain Layout

        norm_a += 2 * PI;
\end_layout

\begin_layout Plain Layout

    return norm_a;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_body
\end_document
