#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass report
\begin_preamble
% DO NOT ALTER THIS PREAMBLE!!!
%
%This preamble is designed to ensure that the document prints
% out as advertised. If you mess with this preamble,
% parts of the document may not print out as expected.  If you
% have problems LaTeXing this file, please contact 
% the documentation team
% email: lyx-docs@lists.lyx.org

\usepackage{ifpdf} % part of the hyperref bundle
\ifpdf % if pdflatex is used
     % set fonts for nicer pdf view
     \IfFileExists{lmodern.sty}{\usepackage{lmodern}}{}
\fi % end if pdflatex is used

\usepackage{tikz}
\usetikzlibrary{mindmap}
\usepackage{attachfile2}
\usepackage{embedfile}
\usepackage{hypgotoe}
\usepackage{verbatim}
%\embedfile{Intro.pdf}
\usepackage{tocloft}
\renewcommand{\cftdot}{}
\usepackage{minitoc}
\definecolor{green}{RGB}{0, 180, 0}
\definecolor{cyan}{RGB}{0, 180, 180}
\definecolor{yellow}{RGB}{102,51,0}
\definecolor{bluekeywords}{rgb}{0.13,0.13,1}
\definecolor{greencomments}{rgb}{0,0.5,0}
\definecolor{redstrings}{rgb}{0.9,0,0}

\usepackage{listings}
\usepackage{courier}
\lstset{language=[Visual]C++,
showspaces=false,
showtabs=false,
breaklines=true,
showstringspaces=false,
breakatwhitespace=true,
escapeinside={(*@}{@*)},
commentstyle=\color{greencomments},
keywordstyle=\color{bluekeywords},
stringstyle=\color{redstrings},
basicstyle=\ttfamily,
tabsize=3
}

\lstloadlanguages{% Check Dokumentation for further languages ...
%[Visual]Basic
%Pascal
%C
C++,
%XML
%HTML
Java
}
%\DeclareCaptionFont{blue}{\color{blue}}

%\captionsetup[lstlisting]{singlelinecheck=false, labelfont={blue}, textfont={blue}}
\usepackage{caption}
\DeclareCaptionFont{white}{\color{white}}
\DeclareCaptionFormat{listing}{\colorbox[cmyk]{0.43, 0.35, 0.35,0.01}{\parbox{\textwidth}{\hspace{15pt}#1#2#3}}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white, singlelinecheck=false, margin=0pt, font={bf,footnotesize}}

% Style definition file generated by highlight 3.13, http://www.andre-simon.de/

\begin{comment}
% Highlighting theme: Acid
\usepackage{marvosym}
\newcommand{\hlstd}[1]{\textcolor[rgb]{0,0,0}{#1}}
\newcommand{\hlnum}[1]{\textcolor[rgb]{0.5,0,0.5}{\bf{#1}}}
\newcommand{\hlesc}[1]{\textcolor[rgb]{1,0,1}{\bf{#1}}}
\newcommand{\hlstr}[1]{\textcolor[rgb]{0.65,0.52,0}{#1}}
\newcommand{\hlpps}[1]{\textcolor[rgb]{0,0,1}{#1}}
\newcommand{\hlslc}[1]{\textcolor[rgb]{0.95,0.47,0}{#1}}
\newcommand{\hlcom}[1]{\textcolor[rgb]{1,0.5,0}{#1}}
\newcommand{\hlppc}[1]{\textcolor[rgb]{0,0.5,0.75}{\bf{#1}}}
\newcommand{\hlopt}[1]{\textcolor[rgb]{1,0,0.5}{\bf{#1}}}
\newcommand{\hlipl}[1]{\textcolor[rgb]{0.62,0.36,1}{#1}}
\newcommand{\hllin}[1]{\textcolor[rgb]{0.19,0.19,0.19}{#1}}
\newcommand{\hlkwa}[1]{\textcolor[rgb]{0.73,0.47,0.47}{\bf{#1}}}
\newcommand{\hlkwb}[1]{\textcolor[rgb]{0.5,0.5,0.75}{\bf{#1}}}
\newcommand{\hlkwc}[1]{\textcolor[rgb]{0,0.5,0.75}{#1}}
\newcommand{\hlkwd}[1]{\textcolor[rgb]{0,0.27,0.4}{#1}}
\definecolor{bgcolor}{rgb}{0.93,0.93,0.93}
\end{comment}

% Highlighting theme: Visual Studio IDE
\newcommand{\hlstd}[1]{\textcolor[rgb]{0,0,0}{#1}}
\newcommand{\hlnum}[1]{\textcolor[rgb]{0,0,0}{#1}}
\newcommand{\hlesc}[1]{\textcolor[rgb]{0.64,0.08,0.08}{#1}}
\newcommand{\hlstr}[1]{\textcolor[rgb]{0.64,0.08,0.08}{#1}}
\newcommand{\hlpps}[1]{\textcolor[rgb]{0,0,1}{#1}}
\newcommand{\hlslc}[1]{\textcolor[rgb]{0,0.5,0}{#1}}
\newcommand{\hlcom}[1]{\textcolor[rgb]{0,0.5,0}{#1}}
\newcommand{\hlppc}[1]{\textcolor[rgb]{0,0,1}{#1}}
\newcommand{\hlopt}[1]{\textcolor[rgb]{0,0,0}{#1}}
\newcommand{\hlipl}[1]{\textcolor[rgb]{0.64,0.08,0.08}{#1}}
\newcommand{\hllin}[1]{\textcolor[rgb]{0.17,0.57,0.69}{#1}}
\newcommand{\hlkwa}[1]{\textcolor[rgb]{0,0,1}{#1}}
\newcommand{\hlkwb}[1]{\textcolor[rgb]{0,0,1}{#1}}
\newcommand{\hlkwc}[1]{\textcolor[rgb]{0.17,0.57,0.69}{#1}}
\newcommand{\hlkwd}[1]{\textcolor[rgb]{0,0,0}{#1}}
\definecolor{bgcolor}{rgb}{1,1,1}

\cftsetindents{part}{-0.325in}{0.25in}

\renewcommand\thesection{\arabic{section}}
\renewcommand\thesubsection{\thesection.\arabic{subsection}}
\end_preamble
\use_default_options true
\begin_modules
multicol
sectionbox
theorems-ams
eqs-within-sections
figs-within-sections
algorithm2e
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 2
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title

\series bold
\shape smallcaps
\size huge
Artificial Intelligence in Mobile Robots
\series default
\shape default
\size default

\begin_inset Newline newline
\end_inset


\shape smallcaps
\size larger
Lab 3 - Navigation control
\end_layout

\begin_layout Author
By
\emph on
 Tobias L 
\emph default
&
\emph on
 Özgun M
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\emph default
Lab Assistant
\emph on
 Ali Abdul Khaliq
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\emph default
Örebro University
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard

\size larger
\bar under
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\size larger
\bar under
Student info
\end_layout

\end_inset


\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout

\size larger
\bar under
Student information
\end_layout

\begin_layout Plain Layout
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "50text%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
Tobias Lindvall
\end_layout

\begin_layout Plain Layout
870603-6657
\end_layout

\begin_layout Plain Layout
tobiaslindwall@gmail.com
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "50text%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
Özgun Mirtchev
\end_layout

\begin_layout Plain Layout
920321-2379
\end_layout

\begin_layout Plain Layout
ozgun.mirtchev@gmail.com
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\size default
\bar default

\begin_inset Float table
placement b
wide false
sideways false
status open

\begin_layout Plain Layout

\size largest
Report handed in: 2016-09-23
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Overview
\end_layout

\begin_layout Standard
The objectives of this lab is to create a point-to-point navigation control
 for the ePuck.
 To do this, a feedback control is needed.
 A feedback control is summarzied to be a system which reads a current state,
 and act accordingly to specified rules.
 In example, if the temperature is too high, a thermostat would correct
 this by lowering the temperature until it's the correct value.
 Vice versa if it's too low.
 Same thing can be applied to the ePuck with its navigation control.
 A feedback control loop will be reading input from the ePuck to lead it
 to the specified position.
 This will be done by using an Achieve-and-exit loop.
 
\end_layout

\begin_layout Standard
This particular loop will: 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Enumerate
{ Measure system output }
\end_layout

\begin_layout Enumerate
{ Calculate the error to the position }
\end_layout

\begin_layout Enumerate
{ If there is an error, it will continue.
 Otherwise it will stop here.
 }
\end_layout

\begin_layout Enumerate
{ Then compute a compensation, from the error values, for the ePuck.}
\end_layout

\begin_layout Enumerate
{ The compensation values will be applied to the ePuck}
\end_layout

\begin_layout Enumerate
Repeat from 1.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The main tasks can be divided into first making the ePuck correct the heading,
 from its current heading to be able to face the target position and then
 correct its position, move towards the point.
 After the implementation is done, there will be some tuning to make sure
 the position of the ePuck becomes more precise.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Tasks
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
-Explain what you did, and how you did it.
 
\end_layout

\begin_layout Plain Layout
-This section should explain what was done for EACH POINT of the lab assignment.
\end_layout

\begin_layout Plain Layout
-In particular, indicate which sections refer to optional parts.
 Indicate which optional parts were done, and how.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Task 1 - Implementing 
\begin_inset Quotes eld
\end_inset

GoTo
\begin_inset Quotes erd
\end_inset

 Divide et Impera (DEI)
\end_layout

\begin_layout Standard
To implement the Achieve-and-exit loop in a C-program, there are 2 options
 of GoTo() algorithms to use.
 One that is called 
\begin_inset Quotes eld
\end_inset

MIMO
\begin_inset Quotes erd
\end_inset

 and another called 
\begin_inset Quotes eld
\end_inset

Divide et Impera
\begin_inset Quotes erd
\end_inset

.
 In this task, the chosen algorithm was 
\begin_inset Quotes eld
\end_inset

Divide et Impera
\begin_inset Quotes erd
\end_inset

.
 The implementation was done by help from the provided algorithm description
 in the slides from lecture 3 (page 105).
 
\end_layout

\begin_layout Standard
Given a target position, the algorithm starts by getting the current position
 of the ePuck.
 This is done by calling the update_position function (implemented in lab
 2) which stores the current position in global variables.
 Using the target position, the distance is calculated and converted into
 errors 
\begin_inset Formula $E_{θ}$
\end_inset

, 
\begin_inset Formula $E_{pos}$
\end_inset

.
 
\begin_inset Formula $E_{θ}$
\end_inset

 is the angle between the facing direction of the ePuck and the target direction.
 
\begin_inset Formula $E_{pos}$
\end_inset

 is the distance between the ePuck and the target position.
 If the angle
\begin_inset Formula $E_{θ}$
\end_inset

 is bigger than the margin of error, 
\begin_inset Formula $delta_{θ}$
\end_inset

, which is a constant, a compensation movement is initiated which make the
 ePuck turn in the correct direction.
 Same procedure for the 
\begin_inset Formula $E_{pos}$
\end_inset

, which also intiates a compensation movement to make ePuck go forward.
 This will continue until the ePuck 
\begin_inset Formula $E_{pos}$
\end_inset

 is smaller than another margin of error 
\begin_inset Formula $delta_{pos}$
\end_inset

.
\end_layout

\begin_layout Standard
Code for this function can be found in appendix: 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperlink{app:DEI}{Divide et Impera}
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Task 2 - Tuning the GAIN parameters
\end_layout

\begin_layout Standard
To make the ePuck go smoother over a trajectory, tuning of the gain parameters
 was required.
 This was tested over simple trajectories after the implementation of the
 algorithm from the previous task.
 At one point it was noticed that the ePuck was oscillating too much to
 reach the target and made it jerk forward instead of going smoothly.
 It affected the end result and made the ePuck to not end up at quite the
 desired position.
 This was an indication that the gain values were too low.
 New values were tested until the desired behaviour of the ePuck was observed.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Task 3 - Implementing a Tracking-procedure
\end_layout

\begin_layout Standard
In this task a simple Tracking procedure is going to be implemented.
 It was done by making a function that takes two parameters.
 The first parameter is a list with coordinates and the second parameter
 is the size of the list, to make the function run that many times.
\end_layout

\begin_layout Standard
The following values was passed to the tracking function for the ePuck to
 test it: 
\end_layout

\begin_layout Standard
\begin_inset Formula ${(x,y)}={(100,100),(0,100),(-100,-100),(-100,0)}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename plot_target.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
The expected trajectory.
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename plot_mimo.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
The performed trajectory of the ePuck.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The position of the ePuck was retrieved by writing the values to a file
 which was then put into a plot drawer.
\end_layout

\begin_layout Standard
Code for this function can be found in appendix: 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperlink{app:Track}{Tracking}
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Task 5 (Optional) - Implementing 
\begin_inset Quotes eld
\end_inset

GoTo
\begin_inset Quotes erd
\end_inset

 (MIMO-controller)
\end_layout

\begin_layout Standard
Another implementation of Achieve-and-exit loop was the GoTo-function, MIMO-cont
roller.
 This algorithm retrieves its values slightly differently compared to its
 counter-part, 
\begin_inset Quotes eld
\end_inset

Divide et Impera
\begin_inset Quotes erd
\end_inset

.
 By using inverse kinematics, it can compute the values for the wheels by
 using kinematic equations on the margin of error of distance and angle.
\end_layout

\begin_layout Standard
Code for this function can be found in appendix: 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperlink{app:MIMO}{MIMO}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Conclusions
\end_layout

\begin_layout Subsection
Implementing the algorithms
\end_layout

\begin_layout Subsubsection
Divide et Impera
\end_layout

\begin_layout Standard
The reason we chose to implement Divide et Impera before MIMO was because
 we were unfamiliar with with the variables inverse kinematics used.
 We didn't continue with it as we weren't sure what the variables in the
 equations represented and how we were to implement them quite yet.
 The Divide et Impera did not use any kinematic equations and was a straight-for
ward implementation.
 We implemented it and by doing that we learned about what each variable
 represented and how we should tune the gain parameters, which enabled us
 to more easily continue to implement MIMO.
\end_layout

\begin_layout Subsubsection
MIMO
\end_layout

\begin_layout Standard
Upon testing the MIMO-controller for the optional task 5, we noticed that
 the ePuck wasn't turning as expected.
 It was going opposite to what it should've been doing and we suspected
 it might be due to the provided equations that we used.
 We tried to change one of the kinematic equations.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
The equations were originally like this:
\end_layout

\begin_layout Plain Layout
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Formula $\begin{cases}
v_{R}=v_{t}+\frac{D}{2}w\\
v_{L}=v_{t}-\frac{D}{2}w
\end{cases}$
\end_inset


\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Plain Layout
Since we noticed that the ePuck was going opposite to what it would've normally
 done, we tried to flip the equations so that the + and the - switched positions
:
\end_layout

\begin_layout Plain Layout
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Formula $\begin{cases}
v_{R}=v_{t}-\frac{D}{2}w\\
v_{L}=v_{t}+\frac{D}{2}w
\end{cases}$
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
This enabled the ePuck to follow its trajectory and go to the desired position,
 at least until we noticed as well that the robot could not move forward
 properly when it was turned around 180 degrees from it's original position.
 Example, we put the target position to (-150, 0), a position on the x-axis.
 The robot turned 180 degrees from its original orientation (0) but could
 not continue forward since it was turning 180 degrees back to normalize
 itself and its orientation and then turning back again to get to the target
 position.
 This caused it to loop around itself to the target position, while at the
 same time getting out of course.
 Not very ideal.
\end_layout

\begin_layout Standard
We tried to figure out what the problem could be.
 After some thinking and calculations we reduced the possible problems down
 to Eth in the goto-function, this included changing the previous equation
 back to how it was from the lecture (not flipped).
 
\end_layout

\begin_layout Standard
The equation we used to compute Eth used to be 
\begin_inset Formula $Eth=Robpos.th-atan(dx,dy)$
\end_inset

.
 We realised that we were subtracting it in the wrong order.
 The normalization of the angle (meaning that the angle always stays in
 the interval [-pi, pi]) in update_position caused the theta of the ePuck
 to change symbol when it was bigger than 180 or -180 degrees, causing it
 to go around itself as it was trying to reach the target.
 This resulted in changing the equation to 
\begin_inset Formula $Eth=atan(dx,dy)-Robpos.th$
\end_inset

.
 Doing this the normalization wouldn't cause the same problem anymore and
 the ePuck was able to move along the x-axis as it should've been able to
 from the start.
\end_layout

\begin_layout Subsection
Tuning the algorithms
\end_layout

\begin_layout Standard
Once we had implemented the algorithms, we had the gains (kp_th, kp_pos)
 set to 1.
 From there we started to test different target positions for the ePuck
 to go and adjusted the values depending on the result.
 If the ePuck turned too slow to face the direction of the target position,
 the value of kp_th was too low.
 Likewise, if the forward motion of the ePuck was too slow, kp_pos was too
 low.
 Using these references, we increased/decreased the values after each testing.
 Since the two algorithms had some differences in how they computed the
 movement to the target position, the gain values were different for each
 algorithm.
 
\end_layout

\begin_layout Standard
For Divide et Impera, the movement of the ePuck would be to correct the
 heading, move forward a bit, and then correct the heading again.
 This is depending on how high the delta_th value is and how much the difference
 between it and Eth is.
 The turning becomes more abrupt than MIMO, since it applies a positive
 value on a wheel and a negative value on the other.
\end_layout

\begin_layout Standard
For MIMO, the movement of the ePuck would be to correct the heading as it
 was moving, meaning that it would lightly turn while moving forward towards
 the target position by applying less speed on a wheel than the other.
 This would result in the trajectory resembling an arc from its start position
 to the target position.
\end_layout

\begin_layout Subsection
Tracking trajectories
\end_layout

\begin_layout Standard
We used the MIMO-algorithm because it was more precise in our tests compared
 to the DEI-algorithm.
\end_layout

\begin_layout Standard
From the plot figure where the ePuck moved, the result was satisfying from
 our point of view because the ePuck didn't avert much from its trajectory
 and stopped at the right spot according to our delta_pos (10 mm).
 If we had a smaller delta_pos, the ePuck was stuttering around a lot to
 get to the exact target spot, which took extra time and in reality made
 it more inaccurate.
 To make it more accurate, more advanced rules could be implemented to help
 it maintain the right course in the trajectory and to stop closer to its
 target.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
-Explain problems encountered and solutions used (don't mention pure programming
 problems or hardware problems).
 
\end_layout

\begin_layout Plain Layout
-Explain how well the resulting program worked, and how it might be improved.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\start_of_appendix
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hypertarget{app:DEI}{Divide et Impera}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

// Divide et Impera
\end_layout

\begin_layout Plain Layout

void goto_dei(double xt, double yt){
\end_layout

\begin_layout Plain Layout

    double dx, dy, Eth, Epos, D = CRD;
\end_layout

\begin_layout Plain Layout

    int vR, vL;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	double Kp_pos = 3.0, Kp_th = 150.0, delta_pos = 10.0, delta_th = 0.25;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

    do {
\end_layout

\begin_layout Plain Layout

        update_position(CRD);
\end_layout

\begin_layout Plain Layout

        dx = xt - RobPos.x;
\end_layout

\begin_layout Plain Layout

        dy = yt - RobPos.y;
\end_layout

\begin_layout Plain Layout

        Epos = sqrt(pow(dx, 2) + pow(dy, 2));
\end_layout

\begin_layout Plain Layout

        Eth = RobPos.th - atan2(dy, dx);
\end_layout

\begin_layout Plain Layout

        printf("dx & dy: %lf %lf
\backslash
n", dx, dy);
\end_layout

\begin_layout Plain Layout

        if (sqrt(pow(Eth, 2)) >= delta_th){
\end_layout

\begin_layout Plain Layout

            vR = -(Kp_th * Eth);
\end_layout

\begin_layout Plain Layout

            vL = - vR;
\end_layout

\begin_layout Plain Layout

            printf("Turned!
\backslash
n
\backslash
n
\backslash
n");
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        else {
\end_layout

\begin_layout Plain Layout

            vR = (Kp_pos * Epos);
\end_layout

\begin_layout Plain Layout

            vL = vR;
\end_layout

\begin_layout Plain Layout

            printf("No turn!
\backslash
n
\backslash
n
\backslash
n");
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        while (abs(vL) > 1000 || abs(vR) > 1000) {
\end_layout

\begin_layout Plain Layout

            vL /= 2;
\end_layout

\begin_layout Plain Layout

            vR /= 2;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        while (abs(vL) < 200 || abs(vR) < 200) {
\end_layout

\begin_layout Plain Layout

            vL *= 1.2;
\end_layout

\begin_layout Plain Layout

            vR *= 1.2;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        printf("Epos: %lf
\backslash
n", Epos);
\end_layout

\begin_layout Plain Layout

        printf("Speed: %d %d
\backslash
n", vL, vR);
\end_layout

\begin_layout Plain Layout

        printf("Eth: %lf
\backslash
n", Eth);
\end_layout

\begin_layout Plain Layout

        SetSpeed(vL, vR);
\end_layout

\begin_layout Plain Layout

        Sleep(100);
\end_layout

\begin_layout Plain Layout

    } while (Epos > delta_pos);
\end_layout

\begin_layout Plain Layout

    Stop();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hypertarget{app:Track}{Tracking-function}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

void track(Position positions[], int size) {
\end_layout

\begin_layout Plain Layout

    int i;
\end_layout

\begin_layout Plain Layout

    printf("size: %d
\backslash
n", sizeof(positions) / sizeof(positions[0]));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    for (i = 0; i < size; ++i) {
\end_layout

\begin_layout Plain Layout

        goto_mimo(positions[i].x, positions[i].y);
\end_layout

\begin_layout Plain Layout

        Sleep(2000);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hypertarget{app:MIMO}{MIMO-controller}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

// MIMO-controller
\end_layout

\begin_layout Plain Layout

void goto_mimo(float xt, float yt){
\end_layout

\begin_layout Plain Layout

    float dx, dy, Eth, Epos, vt, w, D = CRD;
\end_layout

\begin_layout Plain Layout

	int vR, vL;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	float Kp_pos = 8, Kp_th = 40, delta_pos = 10.0;  // double instead of float?
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    do {
\end_layout

\begin_layout Plain Layout

        update_position(CRD);
\end_layout

\begin_layout Plain Layout

        dx = xt - RobPos.x;
\end_layout

\begin_layout Plain Layout

        dy = yt - RobPos.y;
\end_layout

\begin_layout Plain Layout

        Epos = sqrt(pow(dx, 2) + pow(dy, 2));	// abs() does not work properly,
 so sqrt(pow()) is used instead
\end_layout

\begin_layout Plain Layout

        Eth = atan2(dy, dx) - RobPos.th;
\end_layout

\begin_layout Plain Layout

        if (Eth > PI)
\end_layout

\begin_layout Plain Layout

            Eth -= 2 * PI;
\end_layout

\begin_layout Plain Layout

        else if (Eth < -PI)
\end_layout

\begin_layout Plain Layout

            Eth += 2 * PI;
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

        vt = Kp_pos * Epos;
\end_layout

\begin_layout Plain Layout

        w = Kp_th * Eth;
\end_layout

\begin_layout Plain Layout

        vR = vt + D/2 * w;
\end_layout

\begin_layout Plain Layout

        vL = vt - D/2 * w;
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

        printf("Speed before normalization: %d %d
\backslash
n", vL, vR);
\end_layout

\begin_layout Plain Layout

        normalize_speeds(&vL, &vR);
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

        printf("Epos: %lf
\backslash
n", Epos);
\end_layout

\begin_layout Plain Layout

        printf("Speed: %d %d
\backslash
n", vL, vR);
\end_layout

\begin_layout Plain Layout

        printf("Eth: %lf
\backslash
n", Eth);
\end_layout

\begin_layout Plain Layout

        SetSpeed(vL, vR);
\end_layout

\begin_layout Plain Layout

        Sleep(10);
\end_layout

\begin_layout Plain Layout

    } while (Epos > delta_pos);
\end_layout

\begin_layout Plain Layout

    Stop();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
Normalize_speed-function for the algorithms
\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

void normalize_speeds(int* vR, int* vL){
\end_layout

\begin_layout Plain Layout

	const int minSpeed = 200;
\end_layout

\begin_layout Plain Layout

    const int maxSpeed = 800;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

    if (*vL > maxSpeed)
\end_layout

\begin_layout Plain Layout

        *vL = maxSpeed;
\end_layout

\begin_layout Plain Layout

    if (*vR > maxSpeed)
\end_layout

\begin_layout Plain Layout

        *vR = maxSpeed;
\end_layout

\begin_layout Plain Layout

    if (*vL < -maxSpeed)
\end_layout

\begin_layout Plain Layout

        *vL = -maxSpeed;
\end_layout

\begin_layout Plain Layout

    if (*vR < -maxSpeed)
\end_layout

\begin_layout Plain Layout

        *vR = -maxSpeed;
\end_layout

\begin_layout Plain Layout

    if ((*vL < minSpeed && *vL >= 0))
\end_layout

\begin_layout Plain Layout

        *vL = minSpeed;
\end_layout

\begin_layout Plain Layout

    if (*vL > -minSpeed && *vL <= 0)
\end_layout

\begin_layout Plain Layout

        *vL = -minSpeed;
\end_layout

\begin_layout Plain Layout

    if ((*vR < minSpeed && *vR >= 0))
\end_layout

\begin_layout Plain Layout

        *vR = minSpeed;
\end_layout

\begin_layout Plain Layout

    if (*vR > -minSpeed && *vR <= 0)
\end_layout

\begin_layout Plain Layout

        *vR = -minSpeed;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_body
\end_document
