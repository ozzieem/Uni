%% LyX 2.2.1 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[english]{report}
\usepackage[T1]{fontenc}
\usepackage[latin9]{luainputenc}
\usepackage{geometry}
\geometry{verbose}
\usepackage{babel}
\usepackage{float}
\usepackage{algorithm2e}
\usepackage{amsmath}
\usepackage{amsthm}
\PassOptionsToPackage{normalem}{ulem}
\usepackage{ulem}
\usepackage[unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=false]
 {hyperref}

\makeatletter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
\numberwithin{equation}{section}
\numberwithin{figure}{section}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
% DO NOT ALTER THIS PREAMBLE!!!
%
%This preamble is designed to ensure that the document prints
% out as advertised. If you mess with this preamble,
% parts of the document may not print out as expected.  If you
% have problems LaTeXing this file, please contact 
% the documentation team
% email: lyx-docs@lists.lyx.org

\usepackage{ifpdf} % part of the hyperref bundle
\ifpdf % if pdflatex is used
     % set fonts for nicer pdf view
     \IfFileExists{lmodern.sty}{\usepackage{lmodern}}{}
\fi % end if pdflatex is used

\usepackage{tikz}
\usetikzlibrary{mindmap}
\usepackage{attachfile2}
\usepackage{embedfile}
\usepackage{hypgotoe}
\usepackage{verbatim}
%\embedfile{Intro.pdf}
\usepackage{tocloft}
\renewcommand{\cftdot}{}
\usepackage{minitoc}
\definecolor{green}{RGB}{0, 180, 0}
\definecolor{cyan}{RGB}{0, 180, 180}
\definecolor{yellow}{RGB}{102,51,0}
\definecolor{bluekeywords}{rgb}{0.13,0.13,1}
\definecolor{greencomments}{rgb}{0,0.5,0}
\definecolor{redstrings}{rgb}{0.9,0,0}

\usepackage{listings}
\usepackage{courier}
\lstset{language=[Visual]C++,
showspaces=false,
showtabs=false,
breaklines=true,
showstringspaces=false,
breakatwhitespace=true,
escapeinside={(*@}{@*)},
commentstyle=\color{greencomments},
keywordstyle=\color{bluekeywords},
stringstyle=\color{redstrings},
basicstyle=\ttfamily,
tabsize=3
}

\lstloadlanguages{% Check Dokumentation for further languages ...
%[Visual]Basic
%Pascal
%C
C++,
%XML
%HTML
Java
}
%\DeclareCaptionFont{blue}{\color{blue}}

%\captionsetup[lstlisting]{singlelinecheck=false, labelfont={blue}, textfont={blue}}
\usepackage{caption}
\DeclareCaptionFont{white}{\color{white}}
\DeclareCaptionFormat{listing}{\colorbox[cmyk]{0.43, 0.35, 0.35,0.01}{\parbox{\textwidth}{\hspace{15pt}#1#2#3}}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white, singlelinecheck=false, margin=0pt, font={bf,footnotesize}}

% Style definition file generated by highlight 3.13, http://www.andre-simon.de/

\begin{comment}
% Highlighting theme: Acid
\usepackage{marvosym}
\newcommand{\hlstd}[1]{\textcolor[rgb]{0,0,0}{#1}}
\newcommand{\hlnum}[1]{\textcolor[rgb]{0.5,0,0.5}{\bf{#1}}}
\newcommand{\hlesc}[1]{\textcolor[rgb]{1,0,1}{\bf{#1}}}
\newcommand{\hlstr}[1]{\textcolor[rgb]{0.65,0.52,0}{#1}}
\newcommand{\hlpps}[1]{\textcolor[rgb]{0,0,1}{#1}}
\newcommand{\hlslc}[1]{\textcolor[rgb]{0.95,0.47,0}{#1}}
\newcommand{\hlcom}[1]{\textcolor[rgb]{1,0.5,0}{#1}}
\newcommand{\hlppc}[1]{\textcolor[rgb]{0,0.5,0.75}{\bf{#1}}}
\newcommand{\hlopt}[1]{\textcolor[rgb]{1,0,0.5}{\bf{#1}}}
\newcommand{\hlipl}[1]{\textcolor[rgb]{0.62,0.36,1}{#1}}
\newcommand{\hllin}[1]{\textcolor[rgb]{0.19,0.19,0.19}{#1}}
\newcommand{\hlkwa}[1]{\textcolor[rgb]{0.73,0.47,0.47}{\bf{#1}}}
\newcommand{\hlkwb}[1]{\textcolor[rgb]{0.5,0.5,0.75}{\bf{#1}}}
\newcommand{\hlkwc}[1]{\textcolor[rgb]{0,0.5,0.75}{#1}}
\newcommand{\hlkwd}[1]{\textcolor[rgb]{0,0.27,0.4}{#1}}
\definecolor{bgcolor}{rgb}{0.93,0.93,0.93}
\end{comment}

% Highlighting theme: Visual Studio IDE
\newcommand{\hlstd}[1]{\textcolor[rgb]{0,0,0}{#1}}
\newcommand{\hlnum}[1]{\textcolor[rgb]{0,0,0}{#1}}
\newcommand{\hlesc}[1]{\textcolor[rgb]{0.64,0.08,0.08}{#1}}
\newcommand{\hlstr}[1]{\textcolor[rgb]{0.64,0.08,0.08}{#1}}
\newcommand{\hlpps}[1]{\textcolor[rgb]{0,0,1}{#1}}
\newcommand{\hlslc}[1]{\textcolor[rgb]{0,0.5,0}{#1}}
\newcommand{\hlcom}[1]{\textcolor[rgb]{0,0.5,0}{#1}}
\newcommand{\hlppc}[1]{\textcolor[rgb]{0,0,1}{#1}}
\newcommand{\hlopt}[1]{\textcolor[rgb]{0,0,0}{#1}}
\newcommand{\hlipl}[1]{\textcolor[rgb]{0.64,0.08,0.08}{#1}}
\newcommand{\hllin}[1]{\textcolor[rgb]{0.17,0.57,0.69}{#1}}
\newcommand{\hlkwa}[1]{\textcolor[rgb]{0,0,1}{#1}}
\newcommand{\hlkwb}[1]{\textcolor[rgb]{0,0,1}{#1}}
\newcommand{\hlkwc}[1]{\textcolor[rgb]{0.17,0.57,0.69}{#1}}
\newcommand{\hlkwd}[1]{\textcolor[rgb]{0,0,0}{#1}}
\definecolor{bgcolor}{rgb}{1,1,1}

\cftsetindents{part}{-0.325in}{0.25in}

\renewcommand\thesection{\arabic{section}}
\renewcommand\thesubsection{\thesection.\arabic{subsection}}

\@ifundefined{showcaptionsetup}{}{%
 \PassOptionsToPackage{caption=false}{subfig}}
\usepackage{subfig}
\makeatother

\usepackage{listings}
\renewcommand{\lstlistingname}{Listing}

\begin{document}

\title{\textbf{\textsc{\huge{}Artificial Intelligence in Mobile Robots}}\\
\textsc{\Large{}Lab 3 - Navigation control}}

\author{By\emph{ Tobias L }\&\emph{ Özgun M}\\
\emph{}\\
Lab Assistant\emph{ Ali Abdul Khaliq}\\
\emph{}\\
Örebro University}

\maketitle
\newpage{}

{\Large{}\uline{}}
\begin{table}[H]
{\Large{}\uline{Student information}}{\Large \par}

\subfloat{%
\begin{minipage}[t]{0.5\textwidth}%
Tobias Lindvall

870603-6657

tobiaslindwall@gmail.com%
\end{minipage}}\\
\subfloat{%
\begin{minipage}[t]{0.5\textwidth}%
Özgun Mirtchev

920321-2379

ozgun.mirtchev@gmail.com%
\end{minipage}}
\end{table}
\begin{table}[b]
{\LARGE{}Report handed in: 2016-09-23}
\end{table}

\newpage{}

\section{Overview}

The objectives of this lab is to create a point-to-point navigation
control for the ePuck. To do this, a feedback control is needed. A
feedback control is summarzied to be a system which reads a current
state, and act accordingly to specified rules. In example, if the
temperature is too high, a thermostat would correct this by lowering
the temperature until it's the correct value. Vice versa if it's too
low. Same thing can be applied to the ePuck with its navigation control.
A feedback control loop will be reading input from the ePuck to lead
it to the specified position. This will be done by using an Achieve-and-exit
loop. 

This particular loop will: 

\begin{figure}[H]
\begin{enumerate}
\item \{ Measure system output \}
\item \{ Calculate the error to the position \}
\item \{ If there is an error, it will continue. Otherwise it will stop
here. \}
\item \{ Then compute a compensation, from the error values, for the ePuck.\}
\item \{ The compensation values will be applied to the ePuck\}
\item Repeat from 1.
\end{enumerate}
\end{figure}

After the implementation is done, there will be some tuning to make
sure the position of the ePuck becomes more precise.

\section{Tasks}


\subsection{Task 1 - Implementing ``GoTo'' (Divide et Impera)}

To implement the Achieve-and-exit loop in a C-program, there are 2
options of GoTo() algorithms to use. One that is called ``MIMO''
and another called ``Divide et Impera''. In this task, the chosen
algorithm was ``Divide et Impera''. The implementation was done
by help from the provided algorithm description in the slides from
lecture 3 (page 105). 

Given a target position, the algorithm starts by getting the current
position of the ePuck. This is done by calling the update\_position
function (implemented in lab 2) which stores the current position
in global variables. Using the target position, the distance is calculated
and converted into errors $E_{\theta}$, $E_{pos}$. $E_{\theta}$
is the angle between the facing direction of the ePuck and the target
direction.$E_{pos}$is the distance between the ePuck and the target
position. If the angle$E_{\theta}$ is bigger than the margin of error,$delta_{\theta}$,
which is a constant, a compensation movement is initiated which make
the ePuck turn in the correct direction. Same procedure for the $E_{pos}$,
which also intiates a compensation movement to make ePuck go forward.
This will continue until the ePuck $E_{pos}$is smaller than another
margin of error $delta_{pos}$.

Code for this function can be found in appendix: \hyperlink{app:DEI}{Divide et Impera}.

\subsection{Task 2 - Tuning the GAIN parameters}

To make the ePuck go smoother over a trajectory, tuning of the gain
parameters was required. This was tested over simple trajectories
after the implementation of the algorithm from the previous task.
At one point it was noticed that the ePuck was oscillating too much
to reach the target and made it jerk forward instead of going smoothly.
It affected the end result and made the ePuck to not end up at quite
the desired position. This was an indication that the gain values
were too low. New values were tested until the desired behaviour of
the ePuck was observed.

\subsection{Task 3 - Implement a Tracking-procedure}

In this task a simple Tracking procedure is going to be implemented.
It was done by making a function that takes two parameters. The first
parameter is a list with coordinates and the second parameter is the
size of the list, to make the function run that many times.

Code for this function can be found in appendix: \hyperlink{app:Track}{Tracking}.

\subsection{Task 5 (Optional) - Implement ``GoTo'' (MIMO-controller)}

Another implementation of Achieve-and-exit loop was the GoTo-function,
MIMO-controller. This algorithm retrieves its values slightly differently
compared to its counter-part, ``Divide et Impera''. By using inverse
kinematics, it can compute the values for the wheels by using kinematic
equations on the margin of error of distance and angle.

Code for this function can be found in appendix: \hyperlink{app:MIMO}{MIMO}.

\section{Conclusions}

\paragraph{Task 1:}
\begin{itemize}
\item Why did we choose to implement Divide et Impera before MIMO?
\begin{itemize}
\item We did try the MIMO-controller first, but since it required some calculations
with inverse kinematics, we didn't continue with it as we weren't
sure what the values should be and how we should use them yet. The
Divide et Impera did not use any kinematic equations and was straight-forward.
We implemented it and learned about how much the values should be
and how we should tune the gain parameters.
\end{itemize}
\item Problems with implementing the algorithm?
\end{itemize}

\paragraph{Task 2:}
\begin{itemize}
\item Discuss the tuning. How much did you tune the gain values with? What
caused you to change it in a certain way?
\end{itemize}

\paragraph{Task 3:}
\begin{itemize}
\item Why did we use Goto-MIMO for this? 
\item Which paths did you try it with? (Include pictures if necessary)
\item Provide pictures with actual trajectories of the ePuck while using
the track function. As well as x,y coordinates of the ePuck (think
about delta\_pos) and compare it with the expected trajectories.
\end{itemize}

\paragraph{Task 5:}

Upon testing the MIMO-controller, we noticed that the ePuck wasn't
turning as expected. It was going opposite to what it should've done
and we suspected it might be due to the provided equations that we
used. We tried changing one of the kinematic equations.

The equations were originally like this:

$\begin{cases}
v_{R}=v_{t}+\frac{D}{2}w\\
v_{L}=v_{t}-\frac{D}{2}w
\end{cases}$\\

Since we noticed that the ePuck was going opposite to what it should've
been doing, we tried to flip the equations so that the + and the -
switched positions:

$\begin{cases}
v_{R}=v_{t}-\frac{D}{2}w\\
v_{L}=v_{t}+\frac{D}{2}w
\end{cases}$\\

This enabled the ePuck to follow its trajectory and go to the desired
position, at least until we noticed as well that the robot could not
move forward properly when it was turned around 180 degrees from it's
original position. Example, we put the target position to (-150, 0),
a position on the x-axis. The robot turned 180 degrees from its original
orientation (0) but could not continue forward since it was turning
180 degrees back to normalize itself and its orientation and then
turning back again to get to the target position. We tried to figure
out what the problem could be. After some thinking and calculations
we reduced the possible problems down to Eth in the goto-function,
this included changing the previous equation back to how it was from
the lecture (not flipped). The equation we used to compute Eth used
to be $Eth=Robpos.th-atan(dx,dy)$. We realised that we're subtracting
it in the wrong order. The normalization in update\_position caused
the theta of the ePuck to change symbol when it was bigger than 180
or -180, causing it to go around itself as it was trying to reach
the target. This resulted in changing the equation to $Eth=atan(dx,dy)-Robpos.th$.
Doing this the normalization wouldn't cause the same problem anymore
and the ePuck was able to move along the x-axis as it should be able
to.

\newpage{}


\appendix
\begin{table}[H]
\hypertarget{app:DEI}{Divide et Impera}

\begin{lstlisting}[language=C]
// Divide et Impera
void goto_dei(double xt, double yt){
    double dx, dy, Eth, Epos, D = CRD;
    int vR, vL;
	
	double Kp_pos = 40.0, Kp_th = 150.0, delta_pos = 10.0, delta_th = 0.15;
	
    do {
        update_position(CRD);
        dx = xt - RobPos.x;
        dy = yt - RobPos.y;
        Epos = sqrt(pow(dx, 2) + pow(dy, 2));
        Eth = RobPos.th - atan2(dy, dx);
        printf("dx & dy: %lf %lf\n", dx, dy);
        if (sqrt(pow(Eth, 2)) >= delta_th){
            vR = -(Kp_th * Eth);
            vL = - vR;
            printf("Turned!\n\n\n");
        }
        else {
            vR = (Kp_pos * Epos);
            vL = vR;
            printf("No turn!\n\n\n");
        }
        while (abs(vL) > 1000 || abs(vR) > 1000) {
            vL /= 2;
            vR /= 2;
            printf("Divided vL or vR!\n");
        }
        while (abs(vL) < 200 || abs(vR) < 200) {
            vL *= 1.2;
            vR *= 1.2;
        }
        printf("Epos: %lf\n", Epos);
        printf("Speed: %d %d\n", vL, vR);
        printf("Eth: %lf\n", Eth);
        SetSpeed(vL, vR);
        Sleep(100);
    } while (Epos > delta_pos);
    Stop();
}
\end{lstlisting}
\end{table}

\begin{table}[H]
\hypertarget{app:Track}{Tracking-function}

\begin{lstlisting}[language=C]
void track(Position positions[], int size) {
    int i;
    printf("size: %d\n", sizeof(positions) / sizeof(positions[0]));

    for (i = 0; i < size; ++i) {
        goto_mimo(positions[i].x, positions[i].y);
        Sleep(2000);
    }
}
\end{lstlisting}
\end{table}

\begin{table}[H]
\hypertarget{app:MIMO}{MIMO-controller}

\begin{lstlisting}[language=C]
// MIMO-controller
void goto_mimo(float xt, float yt){
    float dx, dy, Eth, Epos, vt, w, D = CRD;
	int vR, vL;
	
	float Kp_pos = 8, Kp_th = 50, delta_pos = 10.0;  // double instead of float?
    
    do {
        update_position(CRD);
        dx = xt - RobPos.x;
        dy = yt - RobPos.y;
        Epos = sqrt(pow(dx, 2) + pow(dy, 2));	// abs() does not work properly, so sqrt(pow()) is used instead
        Eth = atan2(dy, dx) - RobPos.th;
        if (Eth > PI)
            Eth -= 2 * PI;
        else if (Eth < -PI)
            Eth += 2 * PI;
		
        vt = Kp_pos * Epos;
        w = Kp_th * Eth;
        vR = vt + D/2 * w;
        vL = vt - D/2 * w;
		
        printf("Speed before normalization: %d %d\n", vL, vR);
        normalize_speeds(&vL, &vR);
		
        printf("Epos: %lf\n", Epos);
        printf("Speed: %d %d\n", vL, vR);
        printf("Eth: %lf\n", Eth);
        SetSpeed(vL, vR);
        Sleep(10);
    } while (Epos > delta_pos);
    Stop();
}
\end{lstlisting}
\end{table}

\end{document}
